<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CA Insight Portal</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 0;
        }
        
        :root {
            --sidebar-width: 240px;
        }

        .container {
            margin-left: var(--sidebar-width);
            margin-right: 0;
            max-width: none;
            padding: 20px;
            transition: margin-left 0.25s ease;
        }
        
        header {
            display: none;
            background: rgba(255, 255, 255, 0.95);
            padding: 25px;
            border-radius: 10px;
            margin-bottom: 25px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        h1 {
            color: #667eea;
            font-size: 32px;
            margin-bottom: 10px;
        }
        
        .subtitle {
            color: #666;
            font-size: 14px;
        }
        
        .tabs {
            display: flex;
            gap: 5px;
            margin-top: 20px;
            border-bottom: 2px solid #e0e0e0;
        }
        
        .tab {
            padding: 12px 24px;
            background: transparent;
            border: none;
            color: #666;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            border-bottom: 3px solid transparent;
            position: relative;
            top: 2px;
        }
        
        .tab:hover {
            color: #667eea;
            background: rgba(102, 126, 234, 0.05);
        }
        
        .tab.active {
            color: #667eea;
            border-bottom-color: #667eea;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        /* Policy Browser Styles */
        .policy-browser-header {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 25px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .policy-filter {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-top: 15px;
        }
        
        .policy-card {
            transition: all 0.2s;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 10px;
            margin-bottom: 20px;
            overflow: hidden;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            position: relative;
            z-index: 1;
        }
        
        .policy-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.15);
        }
        
        .policy-card-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            color: white;
        }
        
        .policy-title {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .policy-meta {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .policy-state-badge {
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
        }
        
        .state-enabled {
            background: #10b981;
        }
        
        .state-disabled {
            background: #ef4444;
        }
        
        .state-enabledForReportingButNotEnforced {
            background: #f59e0b;
        }
        
        .policy-id {
            font-size: 11px;
            opacity: 0.9;
        }
        
        .policy-card-body {
            padding: 20px;
        }
        
        .policy-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
            border: 1px solid #e5e7eb;
        }
        
        .policy-table th {
            background: #f9fafb;
            color: #374151;
            font-weight: 600;
            text-align: left;
            padding: 12px 16px;
            border: 1px solid #e5e7eb;
            width: 180px;
        }
        
        .policy-table td {
            padding: 12px 16px;
            background: white;
            color: #1f2937;
            border: 1px solid #e5e7eb;
        }
        
        .policy-table tr:nth-child(odd) td {
            background-color: white;
        }
        
        .policy-table tr:hover td {
            background: #f0f9ff;
        }
        
        .policy-table tr:hover th {
            background: #f0f9ff;
        }
        
        .upload-section {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 25px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .upload-section-compact {
            background: rgba(255, 255, 255, 0.95);
            padding: 10px 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .upload-section-compact h3 {
            margin: 0;
            font-size: 14px;
            color: #555;
            font-weight: 600;
        }
        
        .btn-compact {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .btn-compact:hover {
            transform: translateY(-1px);
            box-shadow: 0 3px 8px rgba(102, 126, 234, 0.3);
        }
        
        .progress-container {
            background: rgba(255, 255, 255, 0.95);
            padding: 15px 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 14px;
            font-weight: 600;
            color: #555;
        }
        
        .progress-bar-bg {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 4px;
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .upload-box {
            border: 2px dashed #667eea;
            border-radius: 8px;
            padding: 30px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .upload-box:hover {
            background: #f8f9ff;
            border-color: #764ba2;
        }
        
        .upload-box.dragover {
            background: #e8ebff;
            border-color: #764ba2;
        }
        
        input[type="file"] {
            display: none;
        }
        
        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        
        .btn:active {
            transform: translateY(0);
        }
        
        .btn-secondary {
            background: white;
            color: #667eea;
            border: 2px solid #667eea;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 25px;
        }
        
        .stat-card {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            text-align: center;
            transition: all 0.3s ease;
            position: relative;
            cursor: help;
        }
        
        .stat-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.15);
        }
        
        .stat-card.gaps {
            border-left: 5px solid #ef4444;
        }
        
        .stat-card.coverage {
            border-left: 5px solid #10b981;
            background: rgba(255, 255, 255, 1);
        }
        
        .stat-card.neutral {
            border-left: 5px solid #667eea;
        }
        
        .stat-card.overall-coverage {
            border-left: 5px solid #667eea;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.12) 0%, rgba(118, 75, 162, 0.12) 100%), rgba(255, 255, 255, 0.95);
        }
        
        .stat-icon {
            font-size: 32px;
            margin-bottom: 10px;
            display: block;
        }
        
        .stat-count {
            font-size: 28px;
            font-weight: 600;
            margin-bottom: 5px;
            color: #333;
        }
        
        .stat-value {
            font-size: 36px;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .stat-card.gaps .stat-value {
            color: #dc2626;
        }
        
        .stat-card.coverage .stat-value {
            color: #059669;
        }
        
        .stat-card.neutral .stat-value {
            color: #667eea;
        }
        
        .stat-card.overall-coverage .stat-value {
            color: #667eea;
        }
        
        .stat-label {
            font-size: 14px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
        }
        
        .stat-progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(0, 0, 0, 0.1);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 10px;
        }
        
        .stat-progress-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.6s ease;
        }
        
        .stat-card.gaps .stat-progress-fill {
            background: linear-gradient(90deg, #ef4444 0%, #dc2626 100%);
        }
        
        .stat-card.coverage .stat-progress-fill {
            background: linear-gradient(90deg, #10b981 0%, #059669 100%);
        }
        
        .stat-card.overall-coverage .stat-progress-fill {
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
        }
        
        .stat-tooltip {
            position: absolute;
            bottom: calc(100% + 10px);
            left: 50%;
            transform: translateX(-50%);
            background: #1f2937;
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 13px;
            line-height: 1.5;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .stat-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: #1f2937;
        }
        
        .stat-card:hover .stat-tooltip {
            opacity: 1;
        }
        
        .stat-card-button {
            margin-top: 15px;
            padding: 8px 16px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.3s;
            width: 100%;
        }
        
        .stat-card-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(102, 126, 234, 0.4);
        }
        
        .filters-section {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 25px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .filters-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }
        
        .filter-group label {
            display: block;
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .filter-group input,
        .filter-group select {
            width: 100%;
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.3s;
        }
        
        .filter-group input:focus,
        .filter-group select:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .identity-type-filters {
            display: flex;
            gap: 20px;
            padding: 15px;
            background: #f9fafb;
            border-radius: 8px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .identity-type-filters-label {
            font-weight: 600;
            color: #667eea;
            font-size: 14px;
            margin-right: 10px;
        }
        
        .identity-type-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            padding: 8px 12px;
            border-radius: 6px;
            transition: background-color 0.2s;
        }
        
        .identity-type-checkbox:hover {
            background-color: #e5e7eb;
        }
        
        .identity-type-checkbox input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: #667eea;
        }
        
        .identity-type-checkbox label {
            cursor: pointer;
            font-size: 14px;
            color: #333;
            user-select: none;
            margin: 0;
        }
        
        .pagination-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem;
            background: white;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            margin: 1rem 0;
            gap: 1rem;
        }
        
        .pagination-nav {
            padding: 0.5rem 1rem;
            background: #0078d4;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background 0.2s;
        }
        
        .pagination-nav:hover:not(:disabled) {
            background: #005a9e;
        }
        
        .pagination-nav:disabled {
            background: #e1e4e8;
            color: #959da5;
            cursor: not-allowed;
        }
        
        .pagination-info {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
        }
        
        .result-range {
            font-size: 13px;
            color: #586069;
        }
        
        .page-numbers {
            display: flex;
            gap: 0.25rem;
            align-items: center;
        }
        
        .page-btn {
            padding: 0.4rem 0.8rem;
            background: white;
            color: #0078d4;
            border: 1px solid #e1e4e8;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }
        
        .page-btn:hover {
            background: #f6f8fa;
            border-color: #0078d4;
        }
        
        .page-btn.active {
            background: #0078d4;
            color: white;
            border-color: #0078d4;
            font-weight: 600;
        }
        
        .page-ellipsis {
            padding: 0 0.5rem;
            color: #959da5;
        }
        
        .results-section {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e0e0e0;
        }
        
        .results-header h2 {
            color: #333;
            font-size: 24px;
        }
        
        .pagination {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .results-grid {
            display: grid;
            gap: 15px;
        }
        
        .result-card {
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            padding: 20px;
            transition: all 0.3s;
        }
        
        .result-card:hover {
            border-color: #667eea;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
        }
        
        .result-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 15px;
        }
        
        .result-info {
            flex: 1;
        }
        
        .result-user {
            font-size: 18px;
            font-weight: 600;
            color: #333;
            margin-bottom: 5px;
        }
        
        .result-app {
            font-size: 14px;
            color: #666;
            margin-bottom: 3px;
        }
        
        .result-lineage {
            font-size: 14px;
            color: #333;
            font-family: 'Courier New', monospace;
            margin-top: 12px;
            padding: 12px;
            background: #f8f9fa;
            border-left: 4px solid #667eea;
            border-radius: 4px;
            font-weight: 500;
            line-height: 1.6;
        }
        
        /* User aggregated view styles */
        .user-card {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            cursor: pointer;
            transition: all 0.3s;
            border-left: 4px solid #f44336;
        }
        
        .user-card:hover {
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
            transform: translateY(-2px);
        }
        
        .user-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .user-name {
            font-size: 18px;
            font-weight: 600;
            color: #333;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .user-type-badge {
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            background: #667eea;
            color: white;
        }
        
        .gap-count {
            font-size: 32px;
            font-weight: 700;
            color: #f44336;
        }
        
        .user-stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-top: 15px;
        }
        
        .user-stat {
            text-align: center;
        }
        
        .user-stat-value {
            font-size: 24px;
            font-weight: 700;
            color: #667eea;
        }
        
        .user-stat-label {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }
        
        /* Access path visualization */
        .gap-card {
            background: white;
            border-radius: 10px;
            margin-bottom: 15px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            border-left: 4px solid #f44336;
            transition: all 0.3s ease;
        }
        
        .gap-card.critical {
            border-left: 8px solid #d32f2f;
            box-shadow: 0 4px 16px rgba(211, 47, 47, 0.3);
        }
        
        .gap-card:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        
        .gap-card-header {
            padding: 15px 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: linear-gradient(135deg, #fff5f5 0%, #ffe8e8 100%);
            transition: background 0.3s ease;
        }
        
        .gap-card-header:hover {
            background: linear-gradient(135deg, #ffeded 0%, #ffd9d9 100%);
        }
        
        .gap-card-header.expanded {
            border-bottom: 1px solid #f0f0f0;
        }
        
        .gap-card-title {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 600;
            color: #f44336;
            font-size: 14px;
        }
        
        .gap-card-expand-icon {
            font-size: 18px;
            color: #f44336;
            transition: transform 0.3s ease;
        }
        
        .gap-card-expand-icon.expanded {
            transform: rotate(180deg);
        }
        
        .gap-summary {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
            flex: 1;
            margin: 0 15px;
        }
        
        .gap-summary-item {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 5px 12px;
            background: white;
            border-radius: 6px;
            font-size: 13px;
            color: #555;
            white-space: nowrap;
        }
        
        .gap-summary-plus {
            color: #666;
            font-weight: bold;
            font-size: 16px;
            padding: 0 4px;
        }
        
        .gap-summary-item .icon {
            font-size: 16px;
        }
        
        .gap-summary-item .label {
            font-weight: 600;
            color: #333;
        }
        
        .gap-card-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }
        
        .gap-card-content.expanded {
            max-height: 2000px;
        }
        
        .access-path {
            background: linear-gradient(135deg, #fff5f5 0%, #ffe8e8 100%);
            border-radius: 10px;
            padding: 20px;
            margin: 15px;
            border: 2px solid #f44336;
        }
        
        .access-path-title {
            font-size: 14px;
            font-weight: 700;
            color: #f44336;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .access-path-steps {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .access-step {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 12px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }
        
        .access-step-icon {
            font-size: 24px;
            min-width: 30px;
            text-align: center;
        }
        
        .access-step-content {
            flex: 1;
        }
        
        .access-step-label {
            font-size: 11px;
            color: #999;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 3px;
        }
        
        .access-step-value {
            font-size: 15px;
            font-weight: 600;
            color: #333;
        }
        
        .access-arrow {
            font-size: 24px;
            color: #f44336;
            text-align: center;
            margin: 5px 0;
        }
        
        .back-button {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 10px 20px;
            background: white;
            border: 2px solid #667eea;
            border-radius: 8px;
            color: #667eea;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 20px;
        }
        
        .back-button:hover {
            background: #667eea;
            color: white;
        }
        
        .detail-view-header {
            background: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .detail-view-title {
            font-size: 24px;
            font-weight: 700;
            color: #333;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .detail-view-stats {
            display: flex;
            gap: 30px;
            font-size: 14px;
            color: #666;
        }
        
        .detail-view-stats strong {
            color: #f44336;
            font-size: 18px;
        }
        
        .controls-tags {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }
        
        .control-tag {
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        
        .control-tag.active {
            background: #4caf50;
            color: white;
        }
        
        .control-tag.inactive {
            background: #e0e0e0;
            color: #999;
        }
        
        .risk-flags {
            margin-top: 10px;
        }
        
        .risk-flag {
            display: inline-block;
            padding: 4px 8px;
            background: #fff3cd;
            border-left: 3px solid #ffc107;
            font-size: 11px;
            color: #856404;
            margin-right: 5px;
            margin-bottom: 5px;
            border-radius: 3px;
        }
        
        .policy-details {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #e0e0e0;
        }
        
        .policy-details-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            padding: 10px;
            background: #f8f9ff;
            border-radius: 6px;
            margin-bottom: 10px;
        }
        
        .policy-details-header:hover {
            background: #e8ebff;
        }
        
        .policy-list {
            display: none;
        }
        
        .policy-list.expanded {
            display: block;
        }
        
        .policy-item {
            padding: 12px;
            background: #fafafa;
            border-radius: 6px;
            margin-bottom: 8px;
            border-left: 3px solid #667eea;
        }
        
        .policy-name {
            font-weight: 600;
            color: #333;
            margin-bottom: 5px;
        }
        
        .policy-state {
            font-size: 12px;
            color: #666;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #667eea;
            font-size: 18px;
        }
        
        .error {
            background: #ffebee;
            color: #c62828;
            padding: 15px;
            border-radius: 6px;
            border-left: 4px solid #c62828;
            margin-bottom: 20px;
        }
        
        .success {
            background: #e8f5e9;
            color: #2e7d32;
            padding: 15px;
            border-radius: 6px;
            border-left: 4px solid #2e7d32;
            margin-bottom: 20px;
        }
        
        .hidden {
            display: none;
        }
        
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #999;
        }
        
        .empty-state-icon {
            font-size: 64px;
            margin-bottom: 20px;
        }
        
        .empty-state-text {
            font-size: 18px;
            margin-bottom: 10px;
        }
        
        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            animation: fadeIn 0.2s;
        }
        
        .modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .modal-content {
            background-color: white;
            border-radius: 8px;
            width: 90%;
            max-width: 800px;
            max-height: 85vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            animation: slideIn 0.3s;
        }
        
        .modal-header {
            padding: 20px 25px;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .modal-header h2 {
            margin: 0;
            font-size: 24px;
            color: #333;
        }
        
        .modal-close {
            background: none;
            border: none;
            font-size: 28px;
            color: #999;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: color 0.2s;
        }
        
        .modal-close:hover {
            color: #333;
        }
        
        .modal-body {
            padding: 25px;
            overflow-y: auto;
            flex: 1;
        }
        
        .excluded-policy-item {
            background: #f8f9fa;
            border-left: 4px solid #dc3545;
            padding: 15px;
            margin-bottom: 12px;
            border-radius: 4px;
        }
        
        .excluded-policy-name {
            font-weight: 600;
            font-size: 16px;
            color: #333;
            margin-bottom: 8px;
        }
        
        .excluded-policy-reason {
            color: #666;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .excluded-policy-reason::before {
            content: "⚠️";
            font-size: 16px;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes slideIn {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        .header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .header-right {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .token-button {
            padding: 10px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            white-space: nowrap;
        }
        
        .token-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        .tenant-info {
            padding: 8px 16px;
            background: #f0f9ff;
            border: 2px solid #667eea;
            border-radius: 6px;
            font-size: 13px;
            color: #334155;
            white-space: nowrap;
        }
        
        .tenant-info strong {
            color: #667eea;
            margin-right: 6px;
        }
        
        .tenant-group {
            margin-bottom: 20px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            overflow: hidden;
        }
        
        .tenant-group-header {
            padding: 15px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
            transition: all 0.3s;
        }
        
        .tenant-group-header:hover {
            background: linear-gradient(135deg, #5568d3 0%, #66428c 100%);
        }
        
        .tenant-group-header .toggle-icon {
            font-size: 18px;
            transition: transform 0.3s;
        }
        
        .tenant-group-header.collapsed .toggle-icon {
            transform: rotate(-90deg);
        }
        
        .tenant-group-body {
            max-height: 2000px;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }
        
        .tenant-group-body.collapsed {
            max-height: 0;
        }
        
        .conditions-banner {
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
            border-left: 4px solid #0ea5e9;
            padding: 12px 16px;
            border-radius: 6px;
            margin-bottom: 20px;
            font-size: 13px;
            color: #0c4a6e;
            display: none;
            align-items: center;
            gap: 10px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }
        
        .conditions-banner.visible {
            display: flex;
        }
        
        .conditions-banner-icon {
            font-size: 16px;
            flex-shrink: 0;
        }
        
        .conditions-banner-text {
            flex: 1;
            line-height: 1.5;
        }
        
        .conditions-banner-text strong {
            color: #075985;
            font-weight: 600;
        }
        
        /* Scan Configuration Banner */
        .scan-config-banner {
            background: rgba(255, 255, 255, 0.95);
            padding: 16px 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            border-left: 4px solid #667eea;
        }
        
        .scan-config-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
        }
        
        .scan-config-header-icon {
            font-size: 20px;
        }
        
        .scan-config-header-text {
            font-size: 14px;
            font-weight: 600;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .scan-config-content {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }
        
        .scan-config-item {
            display: flex;
            align-items: center;
            gap: 10px;
            background: #f8f9fa;
            padding: 10px 16px;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
        }
        
        .scan-config-item-icon {
            font-size: 24px;
        }
        
        .scan-config-item-content {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        
        .scan-config-item-label {
            font-size: 11px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            font-weight: 500;
            white-space: nowrap;
        }
        
        .scan-config-item-value {
            font-size: 15px;
            color: #333;
            font-weight: 600;
        }
        
        /* Guest User Actions Info Banner */
        .guest-user-actions-banner {
            display: none;
            background: #fef3c7;
            border: 2px solid #f59e0b;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .guest-user-actions-banner.visible {
            display: block;
        }
        
        .guest-user-actions-banner-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .guest-user-actions-banner-icon {
            font-size: 24px;
        }
        
        .guest-user-actions-banner-title {
            font-size: 14px;
            font-weight: 700;
            color: #92400e;
            margin: 0;
        }
        
        .guest-user-actions-banner-content {
            color: #78350f;
            line-height: 1.5;
            font-size: 13px;
        }
        
        .guest-user-actions-item {
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 6px;
        }
        
        .guest-user-actions-item-header {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
            color: #1565c0;
            margin-bottom: 5px;
        }
        
        .guest-user-actions-item-detail {
            font-size: 14px;
            color: #555;
            margin-left: 28px;
        }
        
        /* Workload/Agent Identities Grant Control Info Banner */
        .workload-grant-control-banner {
            background: linear-gradient(135deg, #fef3cd 0%, #fff4e6 100%);
            border-left: 4px solid #ff9800;
            padding: 16px 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: none;
            box-shadow: 0 2px 8px rgba(255, 152, 0, 0.1);
        }
        
        .workload-grant-control-banner.visible {
            display: block;
        }
        
        .workload-grant-control-banner-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .workload-grant-control-banner-icon {
            font-size: 20px;
        }
        
        .workload-grant-control-banner-title {
            font-size: 15px;
            font-weight: 600;
            color: #e65100;
        }
        
        .workload-grant-control-banner-content {
            font-size: 14px;
            color: #5d4037;
            line-height: 1.6;
        }
        
        .workload-grant-control-banner-content strong {
            color: #e65100;
        }

        /* ===== SIDEBAR ELEMENT ===== */
        #appSidebar {
            display: flex;
            flex-direction: column;
            width: var(--sidebar-width);
            min-width: 240px;
            height: 100vh;
            position: fixed;
            left: 0;
            top: 0;
            background: linear-gradient(180deg, #4a5fc1 0%, #5a3a8a 100%);
            z-index: 200;
            box-shadow: 3px 0 12px rgba(0, 0, 0, 0.2);
        }

        .sidebar-logo {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 24px 20px 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.15);
        }

        .sidebar-logo-icon {
            font-size: 28px;
        }

        .sidebar-logo-title {
            color: white;
            font-size: 18px;
            font-weight: 700;
            line-height: 1.2;
        }

        .sidebar-logo-sub {
            color: rgba(255, 255, 255, 0.7);
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .sidebar-nav {
            flex: 1;
            padding: 16px 0;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: rgba(255,255,255,0.25) transparent;
        }

        .sidebar-nav::-webkit-scrollbar {
            width: 4px;
        }

        .sidebar-nav::-webkit-scrollbar-track {
            background: transparent;
        }

        .sidebar-nav::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.25);
            border-radius: 2px;
        }

        .sidebar-nav::-webkit-scrollbar-thumb:hover {
            background: rgba(255,255,255,0.45);
        }

        .sidebar-nav-item {
            display: flex;
            align-items: center;
            gap: 12px;
            width: 100%;
            padding: 13px 20px;
            background: transparent;
            border: none;
            border-left: 3px solid transparent;
            color: rgba(255, 255, 255, 0.8);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            text-align: left;
            transition: all 0.2s;
        }

        .sidebar-nav-item:hover {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border-left-color: rgba(255, 255, 255, 0.4);
        }

        .sidebar-nav-item.active {
            background: rgba(255, 255, 255, 0.18);
            color: white;
            font-weight: 600;
            border-left-color: white;
        }

        .sidebar-nav-subitem {
            display: flex;
            align-items: center;
            gap: 10px;
            width: 100%;
            padding: 9px 20px 9px 44px;
            background: transparent;
            border: none;
            border-left: 3px solid transparent;
            color: rgba(255, 255, 255, 0.65);
            font-size: 13px;
            cursor: pointer;
            text-align: left;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .sidebar-nav-subitem:hover {
            background: rgba(255, 255, 255, 0.08);
            color: rgba(255, 255, 255, 0.9);
        }

        .sidebar-nav-subitem.active {
            background: rgba(255, 255, 255, 0.13);
            color: white;
            border-left-color: rgba(255, 255, 255, 0.55);
        }

        .sidebar-nav-subitem-icon {
            font-size: 14px;
            min-width: 18px;
            text-align: center;
        }

        .sidebar-nav-icon {
            font-size: 18px;
            min-width: 24px;
            text-align: center;
        }

        .sidebar-footer {
            padding: 16px;
            border-top: 1px solid rgba(255, 255, 255, 0.15);
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .tenant-info-sidebar {
            padding: 8px 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.85);
        }

        .tenant-info-sidebar strong {
            color: rgba(255, 255, 255, 0.7);
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: block;
            margin-bottom: 2px;
        }

        .tenant-id-sidebar {
            color: white;
            font-weight: 600;
            font-size: 12px;
            word-break: break-all;
        }

        /* ===== SIDEBAR POLICY FILTERS PANEL ===== */
        #sidebarPolicyFilters {
            display: none;
            flex-direction: column;
            padding: 4px 10px 12px;
            gap: 6px;
        }

        #sidebarPolicyFilters .sidebar-filters-title {
            color: rgba(255, 255, 255, 0.5);
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1.2px;
            padding-bottom: 4px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        /* Policy State item - full-width container at top of filter panel */
        #sidebarPolicyFilters .sidebar-filter-state-item {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        /* Policy State select - matches multi-select button style (dark translucent, white text) */
        #sidebarPolicyFilters #policyStateFilter {
            width: 100% !important;
            box-sizing: border-box !important;
            padding: 4px 28px 4px 8px !important;
            background: rgba(255,255,255,0.1) !important;
            border: 1px solid rgba(255,255,255,0.18) !important;
            border-radius: 4px !important;
            color: rgba(255,255,255,0.9) !important;
            font-size: 11px !important;
            font-family: inherit !important;
            cursor: pointer;
            appearance: none !important;
            -webkit-appearance: none !important;
            height: 28px;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='6' viewBox='0 0 10 6'%3E%3Cpath fill='rgba(255,255,255,0.65)' d='M0 0 L5 6 L10 0 Z'/%3E%3C/svg%3E") !important;
            background-repeat: no-repeat !important;
            background-position: right 9px center !important;
        }

        #sidebarPolicyFilters #policyStateFilter option {
            background: white;
            color: #333;
            font-size: 14px;
        }

        #sidebarPolicyFilters #policyStateFilter:focus {
            outline: none;
            border-color: rgba(255,255,255,0.4) !important;
            box-shadow: 0 0 0 2px rgba(255,255,255,0.08);
        }

        #sidebarPolicyFilters #policyStateFilter:hover {
            background-color: rgba(255,255,255,0.18) !important;
            border-color: rgba(255,255,255,0.35) !important;
        }

        /* Reset Filters button - full width, below all filter rows */
        #sidebarPolicyFilters .reset-filters-sidebar-btn {
            display: block;
            width: 100%;
            padding: 7px 10px;
            background: rgba(255,255,255,0.12);
            border: 1px solid rgba(255,255,255,0.25);
            border-radius: 4px;
            color: rgba(255,255,255,0.9);
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
            box-sizing: border-box;
            text-align: center;
            margin-top: 6px;
        }

        #sidebarPolicyFilters .sidebar-filter-bottom-sep {
            border-top: 1px solid rgba(255,255,255,0.1);
            margin-top: 10px;
        }

        #sidebarPolicyFilters .reset-filters-sidebar-btn:hover {
            background: rgba(255,255,255,0.22);
            color: white;
        }

        /* --- Glassmorphism container: stripped for sidebar --- */
        #sidebarPolicyFilters .policy-filter {
            margin: 0 !important;
        }

        #sidebarPolicyFilters .glassmorphism-container {
            background: transparent !important;
            border: none !important;
            border-radius: 0 !important;
            padding: 0 !important;
            box-shadow: none !important;
            backdrop-filter: none !important;
        }

        /* Override .collapsed — always show filters in sidebar */
        #sidebarPolicyFilters .filters-collapsible-content {
            max-height: none !important;
            opacity: 1 !important;
            overflow: visible !important;
        }

        /* Hide the "Filter Options" collapsible header — sidebar title is enough */
        #sidebarPolicyFilters .filters-collapse-header {
            display: none !important;
        }

        /* Category cards: invisible containers */
        #sidebarPolicyFilters .categories-glass-grid {
            display: flex !important;
            flex-direction: column !important;
            gap: 5px !important;
        }

        #sidebarPolicyFilters .category-glass-card {
            background: transparent !important;
            border: none !important;
            border-radius: 0 !important;
            padding: 0 !important;
            box-shadow: none !important;
            display: block !important;
            transform: none !important;
            transition: none !important;
        }

        #sidebarPolicyFilters .category-glass-card:hover {
            transform: none !important;
            background: transparent !important;
            box-shadow: none !important;
        }

        /* Hide category icon/title headers (Targets / Conditions / Controls) */
        #sidebarPolicyFilters .category-glass-header {
            display: none !important;
        }

        /* All inner grids → equal 2-column, constrained to panel width */
        #sidebarPolicyFilters .filters-glass-grid-2col,
        #sidebarPolicyFilters .filters-glass-grid-3col {
            display: grid !important;
            grid-template-columns: 1fr 1fr !important;
            gap: 4px !important;
            flex: unset !important;
            min-width: 0 !important;
        }

        /* Each filter item: no decoration */
        #sidebarPolicyFilters .filter-glass-item {
            background: transparent !important;
            border: none !important;
            border-radius: 0 !important;
            padding: 0 !important;
            min-width: 0 !important;
            overflow: visible;
        }

        #sidebarPolicyFilters .filter-glass-item:hover {
            background: transparent !important;
        }

        /* Filter item label */
        #sidebarPolicyFilters .filter-glass-item label {
            font-size: 11px !important;
            color: rgba(255,255,255,0.55) !important;
            margin-bottom: 2px !important;
            text-transform: uppercase;
            letter-spacing: 0.4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
            display: block !important;
        }

        /* Dropdown container: fill the grid cell exactly */
        #sidebarPolicyFilters .multi-select-dropdown {
            min-width: 0 !important;
            width: 100% !important;
            box-sizing: border-box !important;
            display: block !important;
        }

        /* Dropdown button: dark sidebar style */
        #sidebarPolicyFilters .filter-glass-item .multi-select-button {
            background: rgba(255,255,255,0.1) !important;
            border: 1px solid rgba(255,255,255,0.18) !important;
            border-radius: 4px !important;
            font-size: 11px !important;
            padding: 4px 20px 4px 7px !important;
            color: rgba(255,255,255,0.9) !important;
            width: 100% !important;
            box-sizing: border-box !important;
            min-height: unset !important;
            height: 28px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        #sidebarPolicyFilters .filter-glass-item .multi-select-button:hover {
            background: rgba(255,255,255,0.18) !important;
            border-color: rgba(255,255,255,0.35) !important;
        }

        #sidebarPolicyFilters .filter-glass-item .multi-select-button span {
            color: rgba(255,255,255,0.9) !important;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: calc(100% - 16px);
            display: inline-block;
        }

        /* Dropdown caret arrow colour */
        #sidebarPolicyFilters .filter-glass-item .multi-select-button::after {
            color: rgba(255,255,255,0.7) !important;
            border-top-color: rgba(255,255,255,0.7) !important;
        }

        /* Dropdown options panel: lock to button width, never overflow the sidebar */
        #sidebarPolicyFilters .multi-select-options {
            left: 0 !important;
            right: 0 !important;
            min-width: 0 !important;
            width: 100% !important;
            max-width: 100% !important;
            box-sizing: border-box !important;
            /* FIX: dark-inherited text colour override — keep options readable */
            color: #222 !important;
            background: white !important;
        }

        /* FIX: option text must be dark on white bg */
        #sidebarPolicyFilters .multi-select-option {
            color: #222 !important;
        }

        #sidebarPolicyFilters .multi-select-option label {
            color: #222 !important;
            font-size: 11px !important;
            text-transform: none !important;
            letter-spacing: 0 !important;
            white-space: normal !important;
            overflow: visible !important;
            text-overflow: unset !important;
            max-width: unset !important;
        }

        /* Expand sidebar width when Policy Browser is active */
        body.policy-browser-active #appSidebar {
            width: max(var(--sidebar-width), 360px);
            min-width: 360px;
        }

        body.policy-browser-active .container {
            margin-left: max(var(--sidebar-width), 360px);
        }

        body.policy-browser-active #sidebarPolicyFilters {
            display: flex;
        }

        /* Layout toggle button (no longer needed, kept for fallback) */
        .layout-toggle-btn { display: none; }
    </style>
</head>
<body>
    <!-- Sidebar Navigation (visible in sidebar layout only) -->
    <aside id="appSidebar">
        <div class="sidebar-logo" title="Discover gaps in Entra Conditional Access policies before attackers do">
            <span class="sidebar-logo-icon">🔐</span>
            <div>
                <div class="sidebar-logo-title">CA Insight</div>
                <div class="sidebar-logo-sub">Portal</div>
            </div>
        </div>
        <nav class="sidebar-nav">
            <button class="sidebar-nav-item active" data-tab="scanManagement" onclick="switchTab('scanManagement', this)" title="Configure and start new scans by selecting identity types and target resources">
                <span class="sidebar-nav-icon">🚀</span>
                <span>Start New Scan</span>
            </button>
            <button class="sidebar-nav-item" data-tab="gapAnalysis" onclick="openGapAnalysis(this)" title="Review identified gaps with detailed breakdowns by identity, resource, and access conditions">
                <span class="sidebar-nav-icon">📊</span>
                <span>Gap Analysis</span>
            </button>
            <div id="gapAnalysisTenantSubmenus"></div>
            <button class="sidebar-nav-item" data-tab="policyBrowser" onclick="switchTab('policyBrowser', this)" title="Explore your Conditional Access policies with resolved object names and full details">
                <span class="sidebar-nav-icon">🔎</span>
                <span>Policy Browser</span>
            </button>
            <!-- Policy Browser filter panel: populated and shown when Policy Browser tab is active -->
            <div id="sidebarPolicyFilters">
                <div class="sidebar-filters-title">Policy Filters</div>
                <!-- Filter elements are moved here by loadPoliciesIntoPolicyBrowser() after injection -->
            </div>
            <button class="sidebar-nav-item" data-tab="about" onclick="switchTab('about', this)" title="About CA Insight">
                <span class="sidebar-nav-icon">ℹ️</span>
                <span>About</span>
            </button>
        </nav>
        <div class="sidebar-footer">
            <div id="currentTenantInfoSidebar" class="tenant-info-sidebar" style="display: none;">
                <strong>Current Tenant</strong>
                <span id="currentTenantIdSidebar" class="tenant-id-sidebar"></span>
            </div>
            <button class="token-button" onclick="showTokenModal()" style="width: 100%;" title="Set or change your Microsoft Graph access token">
                🔑 Set Token
            </button>
        </div>
    </aside>

    <div class="container">
        <header>
            <div class="header-top">
                <div>
                    <h1>🔐 CA Insight Portal</h1>
                    <p class="subtitle">Comprehensive Conditional Access Policy Analysis Platform</p>
                </div>
                <div class="header-right">
                    <div id="currentTenantInfo" class="tenant-info" style="display: none;">
                        <strong>Current Tenant:</strong><span id="currentTenantId">Not authenticated</span>
                    </div>
                    <button id="headerTokenButton" class="token-button" onclick="showTokenModal()" title="Set or change your Microsoft Graph access token">
                        🔑 Set Token
                    </button>
                </div>
            </div>
            
            <div class="tabs">
                <button class="tab active" onclick="switchTab('scanManagement', this)" title="Configure and start new scans by selecting identity types and target resources">Start New Scan</button>
                <button class="tab" onclick="openGapAnalysis(this)" title="Review identified gaps with detailed breakdowns by identity, resource, and access conditions">Gap Analysis</button>
                <button class="tab" onclick="switchTab('policyBrowser', this)" title="Explore your Conditional Access policies with resolved object names and full details">Policy Browser</button>
                <button class="tab" onclick="switchTab('about', this)">About</button>
            </div>
        </header>
        
        <!-- Scan Management Tab Content -->
        <div id="scanManagement" class="tab-content active">
            <!-- Scan Configuration Form -->
            <div class="upload-section">
                <h2 style="margin-bottom: 20px;">🚀 Start New Scan</h2>
                <form id="scanForm" style="background: white; padding: 30px; border-radius: 10px;">
                    
                    <!-- Conditions Banner -->
                    <div id="conditionsBanner" class="conditions-banner">
                        <span class="conditions-banner-icon">ℹ️</span>
                        <div class="conditions-banner-text">
                            <strong>Conditions included in gap analysis:</strong> <span id="conditionsText"></span>
                        </div>
                    </div>
                    
                    <!-- Guest Users + User Actions Info Banner -->
                    <div class="guest-user-actions-banner" id="guestUserActionsBanner">
                        <div class="guest-user-actions-banner-header">
                            <span class="guest-user-actions-banner-icon">⚠️</span>
                            <h3 class="guest-user-actions-banner-title">Evaluation Scope</h3>
                        </div>
                        <div class="guest-user-actions-banner-content">
                            <p style="margin: 0;">This scan evaluates <strong>only local guests</strong> (guests created in your tenant), as user actions for external guests apply to their home tenant.</p>
                        </div>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                        <div>
                            <label style="display: block; margin-bottom: 8px; font-weight: 600;">Identities</label>
                            <select id="assignments" style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 6px;">
                                <option value="agent-identities">🤖 Agent Identities</option>
                                <option value="guests">💼 Guest and External Users</option>
                                <option value="users" selected>👤 Member Users</option>
                                <option value="workload-identities">🚀 Workload Identities</option>
                            </select>
                        </div>
                        
                        <div>
                            <label style="display: block; margin-bottom: 8px; font-weight: 600;">Target Resources</label>
                            <select id="target_resources" style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 6px;">
                                <option value="agent-resources">🤖 Agent Resources</option>
                                <option value="cloud-apps" selected>📱 Cloud Applications</option>
                                <option value="user-actions">👆 User Actions</option>
                            </select>
                        </div>
                    </div>
                    
                    <!-- Cache Clearing Options -->
                    <div style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 6px; border: 1px solid #e0e0e0;">
                        <h4 style="margin: 0 0 12px 0; font-size: 14px; color: #667eea;">🗑️ Cache Management</h4>
                        <div style="display: flex; gap: 15px; flex-wrap: wrap;">
                            <label style="display: flex; align-items: center; cursor: pointer;" title="No cache clearing - use existing cached data">
                                <input type="radio" name="clearCache" value="" checked style="margin-right: 8px;">
                                <span style="font-size: 14px;">Keep Cache</span>
                            </label>
                            <label style="display: flex; align-items: center; cursor: pointer;" title="Clear all cached data (tenant-wide and policy-specific)">
                                <input type="radio" name="clearCache" value="all" style="margin-right: 8px;">
                                <span style="font-size: 14px;">Clear All</span>
                            </label>
                            <label style="display: flex; align-items: center; cursor: pointer;" title="Clear only policy-specific caches (users, groups, roles, applications, service principals resolved from policies)">
                                <input type="radio" name="clearCache" value="policies" style="margin-right: 8px;">
                                <span style="font-size: 14px;">Clear Policies</span>
                            </label>
                            <label style="display: flex; align-items: center; cursor: pointer;" title="Clear only tenant-wide caches (active users, agent identities, workload identities, named locations, auth contexts)">
                                <input type="radio" name="clearCache" value="tenant" style="margin-right: 8px;">
                                <span style="font-size: 14px;">Clear Tenant</span>
                            </label>
                        </div>
                        <small style="color: #666; font-size: 11px; display: block; margin-top: 8px;">
                            💡 <strong>Keep Cache:</strong> Reuse existing data (faster). 
                            <strong>Clear All:</strong> Refresh everything. 
                            <strong>Clear Policies:</strong> Refresh policy-derived objects only. 
                            <strong>Clear Tenant:</strong> Refresh tenant-wide objects only.
                        </small>
                    </div>
                    
                    <!-- Identity Filters -->
                    <div style="margin-bottom: 20px; padding: 20px; background: #f8f9fa; border-radius: 8px; border: 1px solid #e0e0e0;">
                        <h4 style="margin: 0 0 15px 0; font-size: 14px; color: #667eea;">🎯 Identity Filters (Optional)</h4>
                        
                        <!-- Import/Export Buttons -->
                        <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                            <button type="button" onclick="importFilterFile()" style="flex: 1; padding: 8px 12px; background: white; border: 2px solid #667eea; color: #667eea; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; transition: all 0.2s;" onmouseover="this.style.background='#667eea'; this.style.color='white'" onmouseout="this.style.background='white'; this.style.color='#667eea'">
                                📁 Import Filter File
                            </button>
                            <button type="button" onclick="exportFilterConfig()" style="flex: 1; padding: 8px 12px; background: white; border: 2px solid #10b981; color: #10b981; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; transition: all 0.2s;" onmouseover="this.style.background='#10b981'; this.style.color='white'" onmouseout="this.style.background='white'; this.style.color='#10b981'">
                                💾 Export Filter Config
                            </button>
                            <input type="file" id="filterFileInput" accept=".json" style="display: none;" onchange="handleFilterFileUpload(event)">
                        </div>
                        
                        <!-- Filter Mode Selection -->
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 8px; font-weight: 600; font-size: 14px;">Filter Mode</label>
                            <select id="filterMode" onchange="updateFilterMode()" style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 14px;">
                                <option value="none">No Filtering (Analyze All Identities)</option>
                                <option value="include">Include Only (Allowlist)</option>
                                <option value="exclude">Exclude (Blocklist)</option>
                            </select>
                        </div>
                        
                        <!-- Include Filter -->
                        <div id="includeFilterSection" style="display: none; margin-bottom: 15px; padding: 15px; background: white; border-radius: 6px; border-left: 4px solid #10b981;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <label style="font-weight: 600; font-size: 14px; color: #10b981;">✓ Include List (Allowlist)</label>
                                <button type="button" onclick="addIncludeId()" style="background: #10b981; color: white; border: none; padding: 5px 12px; border-radius: 4px; cursor: pointer; font-size: 12px;">+ Add ID</button>
                            </div>
                            <div id="includeIdsList" style="max-height: 200px; overflow-y: auto; margin-bottom: 10px;">
                                <!-- Include IDs will be added here -->
                            </div>
                            <div style="display: flex; gap: 8px; margin-bottom: 5px;">
                                <select id="includeIdType" style="padding: 8px; border: 2px solid #e0e0e0; border-radius: 4px; font-size: 12px; min-width: 100px;">
                                    <option value="users">👤 User</option>
                                    <option value="groups">👥 Group</option>
                                    <option value="roles">🎭 Role</option>
                                </select>
                                <input type="text" id="includeIdInput" placeholder="Paste Object ID (GUID)" style="flex: 1; padding: 8px; border: 2px solid #e0e0e0; border-radius: 4px; font-family: monospace; font-size: 12px;">
                            </div>
                            <small style="color: #666; font-size: 11px; display: block; margin-top: 5px;">Select type, paste ID, then press Enter or click "+ Add ID". Groups and roles will be resolved to their members.</small>
                        </div>
                        
                        <!-- Exclude Filter -->
                        <div id="excludeFilterSection" style="display: none; margin-bottom: 15px; padding: 15px; background: white; border-radius: 6px; border-left: 4px solid #ef4444;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <label style="font-weight: 600; font-size: 14px; color: #ef4444;">✗ Exclude List (Blocklist)</label>
                                <button type="button" onclick="addExcludeId()" style="background: #ef4444; color: white; border: none; padding: 5px 12px; border-radius: 4px; cursor: pointer; font-size: 12px;">+ Add ID</button>
                            </div>
                            <div id="excludeIdsList" style="max-height: 200px; overflow-y: auto; margin-bottom: 10px;">
                                <!-- Exclude IDs will be added here -->
                            </div>
                            <div style="display: flex; gap: 8px; margin-bottom: 5px;">
                                <select id="excludeIdType" style="padding: 8px; border: 2px solid #e0e0e0; border-radius: 4px; font-size: 12px; min-width: 100px;">
                                    <option value="users">👤 User</option>
                                    <option value="groups">👥 Group</option>
                                    <option value="roles">🎭 Role</option>
                                </select>
                                <input type="text" id="excludeIdInput" placeholder="Paste Object ID (GUID)" style="flex: 1; padding: 8px; border: 2px solid #e0e0e0; border-radius: 4px; font-family: monospace; font-size: 12px;">
                            </div>
                            <small style="color: #666; font-size: 11px; display: block; margin-top: 5px;">Select type, paste ID, then press Enter or click "+ Add ID". Groups and roles will be resolved to their members.</small>
                        </div>
                        
                        <!-- Conflict Warning -->
                        <div id="filterConflictWarning" style="display: none; padding: 12px; background: #fef3c7; border: 1px solid #f59e0b; border-radius: 6px; margin-bottom: 10px;">
                            <strong style="color: #92400e;">⚠️ Conflict Detected:</strong>
                            <span id="conflictMessage" style="color: #78350f; font-size: 12px;"></span>
                        </div>
                        
                        <!-- Filter Summary -->
                        <div id="filterSummary" style="display: none; padding: 10px; background: #e0e7ff; border-radius: 6px; font-size: 12px; color: #3730a3;">
                            <strong>Filter Summary:</strong> <span id="filterSummaryText"></span>
                        </div>
                    </div>
                    
                    <button type="submit" class="btn" style="width: 100%; padding: 14px; font-size: 16px;">
                        🚀 Start Scan
                    </button>
                </form>
            </div>
            
            
        </div>
        <!-- End Scan Management Tab -->
        
        <!-- Gap Analysis Tab Content -->
        <div id="gapAnalysis" class="tab-content">

        <!-- Static upload area (always visible) -->
        <div id="uploadSectionLarge" class="upload-section">
            <h2 style="margin-bottom: 15px;">📊 Manually Upload Analysis Report</h2>
            <div class="upload-box" id="uploadBox">
                <p style="font-size: 18px; margin-bottom: 10px;">📁 Drag & Drop JSON file here</p>
                <p style="color: #999; margin-bottom: 15px;">or</p>
                <button class="btn" onclick="document.getElementById('fileInput').click()">📄 Choose File</button>
                <input type="file" id="fileInput" accept=".json" onchange="uploadFile()">
            </div>
            <p style="margin-top: 14px; font-size: 12px; color: #aaa; text-align: center;">
                or <a href="#" onclick="switchTab('scanManagement', document.querySelector('.sidebar-nav-item[data-tab=scanManagement]')); return false;" style="color: #8ab4f8; text-decoration: none; border-bottom: 1px dashed #8ab4f8;">start a new scan</a> in the <em>Start New Scan</em> tab
            </p>
        </div>

        <div id="uploadSectionCompact" class="upload-section-compact hidden">
            <h3>✅ Analysis Report Loaded</h3>
            <button class="btn-compact" onclick="document.getElementById('fileInput').click()">Upload New Report</button>
        </div>

        <div id="messageArea"></div>

        <div id="progressContainer" class="progress-container hidden">
            <div class="progress-header">
                <span id="progressLabel">Uploading...</span>
                <span id="progressPercent">0%</span>
            </div>
            <div class="progress-bar-bg">
                <div id="progressBar" class="progress-bar"></div>
            </div>
        </div>

        <!-- Tenant Scan History (shown when a tenant is selected from sidebar) -->
        <div id="gapAnalysisScanHistory" style="display: none; margin-bottom: 30px;">
            <div style="background: white; padding: 20px; border-radius: 10px;">
                <h2 style="margin-bottom: 20px;">🕰️ <span id="scanHistoryTenantTitle">Scan History</span></h2>
                <div id="scanHistoryContent">
                    <p style="text-align: center; color: #999; padding: 40px;">Loading scans...</p>
                </div>
            </div>
        </div>

        <div id="statsSection" class="hidden">
            <!-- Scan Configuration Banner -->
            <div id="scanConfigBanner" class="scan-config-banner">
                <div class="scan-config-header">
                    <span class="scan-config-header-icon">⚙️</span>
                    <span class="scan-config-header-text">Scan Configuration</span>
                </div>
                <div class="scan-config-content">
                    <div class="scan-config-item">
                        <span class="scan-config-item-icon" id="scanConfigIdentityIcon">👤</span>
                        <div class="scan-config-item-content">
                            <span class="scan-config-item-label">Identity Scope</span>
                            <span class="scan-config-item-value" id="scanConfigIdentityType">Users</span>
                        </div>
                    </div>
                    <div class="scan-config-item">
                        <span class="scan-config-item-icon" id="scanConfigResourceIcon">☁️</span>
                        <div class="scan-config-item-content">
                            <span class="scan-config-item-label">Target Resources</span>
                            <span class="scan-config-item-value" id="scanConfigResourceType">Cloud Applications</span>
                        </div>
                    </div>
                    <div class="scan-config-item" id="scanConfigIncludedUsersItem" style="display: none;">
                        <span class="scan-config-item-icon">✅</span>
                        <div class="scan-config-item-content">
                            <span class="scan-config-item-label">Included Identities</span>
                            <span class="scan-config-item-value" id="scanConfigIncludedUsers">-</span>
                        </div>
                    </div>
                    <div class="scan-config-item" id="scanConfigExcludedUsersItem" style="display: none;">
                        <span class="scan-config-item-icon">❌</span>
                        <div class="scan-config-item-content">
                            <span class="scan-config-item-label">Excluded Identities</span>
                            <span class="scan-config-item-value" id="scanConfigExcludedUsers">-</span>
                        </div>
                    </div>
                    <div class="scan-config-item">
                        <span class="scan-config-item-icon">⏱️</span>
                        <div class="scan-config-item-content">
                            <span class="scan-config-item-label">Analysis Duration</span>
                            <span class="scan-config-item-value" id="scanConfigDuration">-</span>
                        </div>
                    </div>
                    <div class="scan-config-item">
                        <span class="scan-config-item-icon">📋</span>
                        <div class="scan-config-item-content">
                            <span class="scan-config-item-label">Excluded Policies</span>
                            <span class="scan-config-item-value" id="scanConfigExcludedCount">0</span>
                        </div>
                        <button class="stat-card-button" onclick="showExcludedPolicies()" id="btnShowExcluded" style="margin-left: 10px; font-size: 11px; padding: 4px 8px;" title="View excluded policies details">View</button>
                    </div>
                </div>
            </div>
            
            <!-- Workload/Agent Identities Grant Control Info Banner -->
            <div id="workloadGrantControlBanner" class="workload-grant-control-banner">
                <div class="workload-grant-control-banner-header">
                    <span class="workload-grant-control-banner-icon">⚠️</span>
                    <span class="workload-grant-control-banner-title">Grant Control Limitation</span>
                </div>
                <div class="workload-grant-control-banner-content">
                    <span id="workloadGrantControlIdentityType">Workload Identities</span> only support the <strong>"Block access"</strong> grant control. Other grant controls such as MFA or authentication strength are not available for this identity type.
                </div>
            </div>
            
            <div class="stats-grid">
                <div class="stat-card gaps">
                    <div class="stat-tooltip">Identities that have at least one access path without strong authentication or blocking controls</div>
                    <span class="stat-icon">⚠️</span>
                    <div class="stat-count" id="countGaps">0</div>
                    <div class="stat-value" id="statTotalIdentities">0</div>
                    <div class="stat-label">Identities with Gaps</div>
                    <div class="stat-progress-bar">
                        <div class="stat-progress-fill" id="progressGaps" style="width: 0%"></div>
                    </div>
                </div>
                <div class="stat-card coverage">
                    <div class="stat-tooltip">Identities protected by policies requiring Multi-Factor Authentication (MFA)</div>
                    <span class="stat-icon">📱</span>
                    <div class="stat-count" id="countMfa">0</div>
                    <div class="stat-value" id="statMfaCoverage">0%</div>
                    <div class="stat-label">MFA Required</div>
                    <div class="stat-progress-bar">
                        <div class="stat-progress-fill" id="progressMfa" style="width: 0%"></div>
                    </div>
                </div>
                <div class="stat-card coverage">
                    <div class="stat-tooltip">Identities protected by policies requiring specific Authentication Strengths (e.g., phishing-resistant MFA)</div>
                    <span class="stat-icon">🔑</span>
                    <div class="stat-count" id="countAuthStrength">0</div>
                    <div class="stat-value" id="statAuthStrengthCoverage">0%</div>
                    <div class="stat-label">Auth Strength Required</div>
                    <div class="stat-progress-bar">
                        <div class="stat-progress-fill" id="progressAuthStrength" style="width: 0%"></div>
                    </div>
                </div>
                <div class="stat-card coverage">
                    <div class="stat-tooltip">Identities that are completely blocked from accessing resources</div>
                    <span class="stat-icon">🚫</span>
                    <div class="stat-count" id="countBlock">0</div>
                    <div class="stat-value" id="statBlockCoverage">0%</div>
                    <div class="stat-label">Blocked</div>
                    <div class="stat-progress-bar">
                        <div class="stat-progress-fill" id="progressBlock" style="width: 0%"></div>
                    </div>
                </div>
                <div class="stat-card overall-coverage">
                    <div class="stat-tooltip">Total of identities protected by MFA, Authentication Strength, or Block policies</div>
                    <span class="stat-icon">📊</span>
                    <div class="stat-count" id="countOverallCoverage">0</div>
                    <div class="stat-value" id="statOverallCoverage">0%</div>
                    <div class="stat-label">Overall Coverage</div>
                    <div class="stat-progress-bar">
                        <div class="stat-progress-fill" id="progressOverallCoverage" style="width: 0%"></div>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="filtersSection" class="filters-section hidden">
            <div class="filters-grid">
                <div class="filter-group">
                    <label for="userFilter">User / Group</label>
                    <input type="text" id="userFilter" placeholder="Search user..." oninput="applyFilters()">
                </div>
                <div class="filter-group">
                    <label for="appFilter">Application</label>
                    <input type="text" id="appFilter" placeholder="Search app..." oninput="applyFilters()">
                </div>
            </div>
        </div>
        
        <div id="resultsSection" class="results-section hidden">
            <div class="results-header">
                <h2>📊 Analysis Results</h2>
                <div class="pagination">
                    <button class="btn btn-secondary" onclick="prevPage()">← Previous</button>
                    <span id="pageInfo">Page 1</span>
                    <button class="btn btn-secondary" onclick="nextPage()">Next →</button>
                </div>
            </div>
            <div id="resultsGrid" class="results-grid"></div>
        </div>
        </div>
        <!-- End Gap Analysis Tab -->
        
        <!-- Policy Browser Tab Content -->
        <div id="policyBrowser" class="tab-content">
            <div id="policyBrowserContent" style="background: rgba(255, 255, 255, 0.95); padding: 20px; border-radius: 10px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);">
                <p style="color: #666; text-align: center; padding: 40px;">Loading policies...</p>
            </div>
        </div>
        <!-- End Policy Browser Tab -->
        
        <!-- About Tab Content -->
        <div id="about" class="tab-content">
            <div style="background: rgba(255, 255, 255, 0.95); padding: 30px; border-radius: 10px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);">
                <h2 style="color: #667eea; margin-bottom: 20px;">ℹ️ About CA Insight</h2>
                
                <div style="margin-bottom: 30px;">
                    <h3 style="color: #333; font-size: 18px; margin-bottom: 10px;">📊 What is CA Insight?</h3>
                    <p style="color: #666; line-height: 1.6; margin-bottom: 15px;">
                        CA Insight is a gap analysis tool that identifies scenarios where identities can access resources using only <strong>username and password</strong> (i.e. without Multi-Factor Authentication (MFA), Authentication Strength, or Block controls). It helps security teams find blind spots in Microsoft Entra Conditional Access policies to strengthen Zero Trust implementations.
                    </p>
                </div>
                                
                <div style="margin-bottom: 30px;">
                    <h3 style="color: #333; font-size: 18px; margin-bottom: 10px;">🔒 Strong Controls Definition</h3>
                    <p style="color: #666; line-height: 1.6; margin-bottom: 10px;">
                        CA Insight only considers an access scenario <strong>protected</strong> if terminated by one of the following controls:
                    </p>
                    <div style="background: #f8f9fa; padding: 20px; border-radius: 6px;">
                        <ul style="color: #666; line-height: 1.8; margin: 0; padding-left: 20px;">
                            <li><strong>🔑 Authentication Strength</strong> — Requires specific authentication methods (e.g., phishing-resistant MFA)</li>
                            <li><strong>📱 Multi-Factor Authentication</strong> — Requires MFA for access</li>
                            <li><strong>🚫 Block</strong> — Blocks access entirely</li>
                        </ul>
                    </div>
                    <p style="color: #666; line-height: 1.6; margin-top: 15px;">
                        <strong>Note:</strong> Other controls like device compliance are <strong>not considered sufficient</strong> when enforced alone, as CA Insight focuses on identity-based verification (MFA/Auth Strength) as the primary security boundary.
                    </p>
                </div>
                
                <div style="margin-bottom: 30px;">
                    <h3 style="color: #333; font-size: 18px; margin-bottom: 10px;">⚡ Performance & Analysis Time</h3>
                    
                    <div style="background: #fff3cd; border-left: 4px solid #ffc107; padding: 20px; border-radius: 6px; margin-bottom: 20px;">
                        <p style="margin: 0; color: #856404; font-weight: bold; font-size: 16px; margin-bottom: 10px;">⏱️ BE PATIENT!</p>
                        <p style="margin: 0; color: #856404; line-height: 1.6;">
                            Evaluating permutations can take considerable time in tenants where several hundred identities are potentially unprotected. Analysis may take 20+ minutes for large-scale scans.
                        </p>
                    </div>
                    
                    <p style="color: #666; line-height: 1.6; margin-bottom: 15px;">
                        Although CA Insight is optimized to avoid processing unnecessary permutations, if an identity is identified as potentially unprotected, CA Insight must evaluate all permutations against existing policies to determine if the identity has gaps.
                    </p>
                    
                    <div style="background: #f8f9fa; padding: 20px; border-radius: 6px; margin-bottom: 15px;">
                        <p style="color: #333; font-weight: bold; margin: 0 0 10px 0;">Example Performance Benchmarks:</p>
                        <p style="color: #666; line-height: 1.6; margin: 0 0 10px 0;">
                            On a machine with <strong>at least 10 logical processors and 16 GB RAM</strong> (typical for modern PCs):
                        </p>
                        <ul style="color: #666; line-height: 1.8; margin: 0; padding-left: 20px;">
                            <li><strong>1,000,000 permutations</strong> ≈ <strong>1 minute</strong> (10 threads, default)</li>
                            <li><strong>20,000,000 permutations</strong> ≈ <strong>20 minutes</strong> (10 threads, default)</li>
                        </ul>
                    </div>
                    
                    <p style="color: #666; line-height: 1.6;">
                        <strong>💡 Tip 1:</strong> When using the CLI interface, you can increase parallelism using the <code>--threads</code> switch to reduce analysis time on machines with more CPU cores. Example: <code>--threads 20</code>
                    </p>
                    
                    <p style="color: #666; line-height: 1.6;">
                        <strong>💡 Tip 2:</strong> When using the CLI interface, you can use the <code>--early-termination</code> switch to stop evaluating an identity after processing a certain percentage of permutations with no gap. This is useful for quick assessments or iterative policy testing. Example: <code>--early-termination 50</code> stops after 50% of an identity's permutations have been processed with no gap found.
                    </p>
                </div>

                <div style="margin-bottom: 30px;">
                    <h3 style="color: #333; font-size: 18px; margin-bottom: 10px;">📖 Documentation</h3>
                    <ul style="color: #666; line-height: 1.8; margin-left: 20px;">
                        <li><a href="https://github.com/emiliensocchi/entra-ca-insight/wiki">https://github.com/emiliensocchi/entra-ca-insight/wiki/workflows</a></li>
                    </ul>
                </div>
            </div>
        </div>
        <!-- End About Tab -->
    
    </div>
    
    <!-- Live Output Modal -->
    <div id="liveOutputModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 3000; padding: 20px;">
        <div style="max-width: 1200px; height: 90%; margin: 0 auto; background: #1e1e1e; border-radius: 10px; display: flex; flex-direction: column; overflow: hidden;">
            <div style="padding: 20px; background: #2d2d2d; border-bottom: 1px solid #444; display: flex; justify-content: space-between; align-items: center;">
                <h3 style="margin: 0; color: white;">📺 Live Scan Output - Scan #<span id="modalScanId"></span></h3>
                <button onclick="closeLiveOutput()" style="background: #ef4444; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 14px;">✕ Close</button>
            </div>
            <div style="flex: 1; overflow-y: auto; padding: 20px; font-family: 'Courier New', monospace; font-size: 13px; color: #d4d4d4; background: #1e1e1e;">
                <pre id="liveOutputContent" style="margin: 0; white-space: pre-wrap; word-wrap: break-word;">Connecting to live output...</pre>
            </div>
        </div>
    </div>

    <!-- Token Authentication Modal -->
    <div id="tokenAuthModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 2000; padding: 20px;">
        <div style="max-width: 600px; margin: 10% auto; background: white; border-radius: 12px; padding: 30px; box-shadow: 0 10px 40px rgba(0,0,0,0.3);">
            <h2 style="color: #667eea; margin-bottom: 10px; font-size: 24px;">🔐 Microsoft Graph Authentication</h2>
            <p style="color: #666; margin-bottom: 20px; font-size: 14px;">Please provide a valid access token to use with CA Insight</p>
            
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px; color: #333; font-weight: 600;">Access Token</label>
                <textarea id="authTokenInput" placeholder="Paste your Microsoft Graph access token here..." 
                          style="width: 100%; min-height: 150px; padding: 12px; border: 2px solid #e0e0e0; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 12px; resize: vertical;"></textarea>
                <small style="color: #999; display: block; margin-top: 5px;">Token must have <strong>Application.Read.All</strong>, <strong>Group.Read.All</strong>, <strong>Policy.Read.All</strong>, <strong>RoleManagement.Read.All</strong> and <strong>User.Read.All</strong> permissions</small>
            </div>
            
            <div id="authStatus" style="display: none; padding: 12px; border-radius: 6px; margin-bottom: 15px; font-size: 14px;"></div>
            
            <div style="display: flex; gap: 10px; justify-content: flex-end;">
                <button id="authCancelBtn" onclick="closeTokenModal()" style="padding: 10px 20px; background: #6b7280; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; display: none;">Cancel</button>
                <button onclick="validateAndStoreToken()" style="padding: 10px 30px; background: #667eea; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600;">Authenticate</button>
            </div>
        </div>
    </div>
    
    <!-- Excluded Policies Modal -->
    <div id="excludedPoliciesModal" class="modal" onclick="closeExcludedPoliciesModal(event)">
        <div class="modal-content" onclick="event.stopPropagation()">
            <div class="modal-header">
                <h2>Excluded Policies</h2>
                <button class="modal-close" onclick="closeExcludedPoliciesModal()">&times;</button>
            </div>
            <div class="modal-body">
                <p style="margin-bottom: 15px; color: #666;">
                    These policies were excluded from gap analysis due to weak conditions or controls that cannot be reliably evaluated.
                </p>
                <div class="filter-group" style="margin-bottom: 15px;">
                    <input type="text" id="excludedPoliciesSearch" placeholder="Search policies..." oninput="filterExcludedPolicies()" style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 14px;">
                </div>
                <div id="excludedPoliciesList"></div>
            </div>
        </div>
    </div>
    
    <script>
        const API_BASE = window.location.origin;
        let currentRunId = null;
        let currentAnalysisMetadata = null; // Store scan metadata including target_resources type
        let authToken = null;
        let tokenValidationInProgress = false;
        let pausedScans = {}; // Store paused scan IDs
        
        // Initialize authentication on page load
        document.addEventListener('DOMContentLoaded', function() {
            initializeAuthentication();
        });
        
        // ============================================================================
        // TOKEN AUTHENTICATION FUNCTIONS
        // ============================================================================
        
        async function initializeAuthentication() {
            // Try to load token from sessionStorage
            const storedToken = sessionStorage.getItem('cainsight_token');
            const storedTenantId = sessionStorage.getItem('cainsight_tenant_id');
            
            // Display stored tenant ID if available
            if (storedTenantId) {
                document.getElementById('currentTenantInfo').style.display = 'block';
                document.getElementById('currentTenantId').textContent = storedTenantId;
                document.getElementById('currentTenantInfoSidebar').style.display = 'block';
                document.getElementById('currentTenantIdSidebar').textContent = storedTenantId;
            }
            
            if (storedToken) {
                authToken = storedToken;
                // Validate stored token
                const isValid = await validateToken(storedToken);
                if (isValid) {
                    console.log('Using cached token from session');
                    await loadPoliciesIntoPolicyBrowser();
                    // Update tenant ID display in case it changed
                    await updateTenantIdDisplay(storedToken);
                    return;
                }
                // Token invalid, clear it
                sessionStorage.removeItem('cainsight_token');
                sessionStorage.removeItem('cainsight_tenant_id');
                authToken = null;
                document.getElementById('currentTenantInfo').style.display = 'none';
                document.getElementById('currentTenantInfoSidebar').style.display = 'none';
            }
            
            // Show token modal if no valid token (user can close it to browse existing scans)
            if (!authToken) {
                showTokenModal();
            }
        }
        
        function showTokenModal(message = null, isError = false) {
            const modal = document.getElementById('tokenAuthModal');
            const statusDiv = document.getElementById('authStatus');
            const cancelBtn = document.getElementById('authCancelBtn');
            const tokenInput = document.getElementById('authTokenInput');
            
            // Always show cancel button - users can close anytime
            cancelBtn.style.display = 'block';
            
            // Clear previous input if first time
            if (!authToken) {
                tokenInput.value = '';
            }
            
            // Show status message if provided
            if (message) {
                statusDiv.style.display = 'block';
                statusDiv.style.background = isError ? '#fee' : '#efe';
                statusDiv.style.color = isError ? '#c00' : '#060';
                statusDiv.style.border = isError ? '1px solid #fcc' : '1px solid #cfc';
                statusDiv.textContent = message;
            } else {
                statusDiv.style.display = 'none';
            }
            
            modal.style.display = 'block';
            tokenInput.focus();
        }
        
        function closeTokenModal() {
            // Allow closing at any time - users can browse existing scans without token
            document.getElementById('tokenAuthModal').style.display = 'none';
        }
        
        async function validateToken(token) {
            try {
                const response = await fetch(`${API_BASE}/api/validate-token`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ token: token })
                });
                const data = await response.json();
                return response.ok && data.valid;
            } catch (error) {
                console.error('Token validation error:', error);
                return false;
            }
        }
        
        async function validateAndStoreToken() {
            if (tokenValidationInProgress) return;
            
            const tokenInput = document.getElementById('authTokenInput');
            const token = tokenInput.value.trim();
            
            if (!token) {
                showTokenModal('Please enter an access token', true);
                return;
            }
            
            tokenValidationInProgress = true;
            showTokenModal('⏳ Validating token...', false);
            
            const isValid = await validateToken(token);
            
            if (isValid) {
                // Store token
                authToken = token;
                sessionStorage.setItem('cainsight_token', token);
                
                // Extract and display tenant ID
                await updateTenantIdDisplay(token);
                
                showTokenModal('✓ Token validated successfully! Loading policies...', false);
                
                // Load policies into policy browser
                await loadPoliciesIntoPolicyBrowser();
                
                // Resume any paused scans
                resumePausedScans();
                
                // Close modal after success
                setTimeout(() => {
                    document.getElementById('tokenAuthModal').style.display = 'none';
                    showMessage('success', 'Authentication successful');
                }, 1000);
            } else {
                showTokenModal('❌ Invalid token. Please check your token and try again.', true);
            }
            
            tokenValidationInProgress = false;
        }
        
        async function updateTenantIdDisplay(token) {
            try {
                const response = await fetch(`${API_BASE}/api/extract-tenant-id`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ token: token })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    const tenantId = data.tenant_id;
                    
                    if (tenantId) {
                        document.getElementById('currentTenantInfo').style.display = 'block';
                        document.getElementById('currentTenantId').textContent = tenantId;
                        document.getElementById('currentTenantInfoSidebar').style.display = 'block';
                        document.getElementById('currentTenantIdSidebar').textContent = tenantId;
                        // Store for later use
                        sessionStorage.setItem('cainsight_tenant_id', tenantId);
                    }
                }
            } catch (error) {
                console.error('Failed to extract tenant ID:', error);
            }
        }
        
        async function handleTokenExpiration() {
            // Pause all running scans
            pauseRunningScans();
            
            // Clear current token
            authToken = null;
            sessionStorage.removeItem('cainsight_token');
            
            // Show re-authentication modal
            showTokenModal('⚠️ Your access token has expired. Please provide a new token to continue.', true);
        }
        
        function pauseRunningScans() {
            // Mark scans as paused (they'll continue in background but we won't show new results)
            Object.keys(active_scans).forEach(scanId => {
                pausedScans[scanId] = true;
                showMessage('warning', `Scan #${scanId} paused due to token expiration`);
            });
        }
        
        function resumePausedScans() {
            // Clear paused state
            pausedScans = {};
            showMessage('info', 'Resuming paused scans...');
            loadScanHistory(); // Refresh scan list
        }
        
        async function loadPoliciesIntoPolicyBrowser() {
            if (!authToken) return;
            
            const contentDiv = document.getElementById('policyBrowserContent');
            contentDiv.innerHTML = '<p style="color: #666; text-align: center; padding: 40px;">⏳ Loading policies from tenant...</p>';
            
            try {
                // Fetch policy browser HTML using the token (POST for security)
                const response = await fetch(`${API_BASE}/api/policies`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ token: authToken })
                });
                
                if (response.status === 401) {
                    // Token expired
                    handleTokenExpiration();
                    return;
                }
                
                if (!response.ok) {
                    throw new Error(`Failed to fetch policies: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                // Inject the generated HTML into policy browser
                if (data.html) {
                    contentDiv.innerHTML = data.html;
                    console.log(`✓ Loaded ${data.count || 0} policies into browser`);
                    showMessage('success', `Loaded ${data.count || 0} policies successfully`);
                    
                    // Move filter sections into the sidebar panel after injection
                    setTimeout(() => {
                        const filterPanel = document.getElementById('sidebarPolicyFilters');
                        if (filterPanel) {
                            // Clean up any previously moved elements (e.g. on refresh)
                            const oldStateItem  = filterPanel.querySelector('.sidebar-filter-state-item');
                            const oldGlass      = filterPanel.querySelector('#policyFiltersContainer');
                            const oldResetBtn   = filterPanel.querySelector('.reset-filters-sidebar-btn');
                            const oldFilterSep  = filterPanel.querySelector('.sidebar-filter-bottom-sep');
                            if (oldStateItem)  oldStateItem.remove();
                            if (oldGlass)      oldGlass.remove();
                            if (oldResetBtn)   oldResetBtn.remove();
                            if (oldFilterSep)  oldFilterSep.remove();

                            // --- Policy State item (full-width, at top) ---
                            const stateItem = document.createElement('div');
                            stateItem.className = 'sidebar-filter-state-item';
                            const stateItemLabel = document.createElement('label');
                            stateItemLabel.textContent = 'Policy State';
                            stateItemLabel.style.cssText = 'font-size:11px;color:rgba(255,255,255,0.55);text-transform:uppercase;letter-spacing:0.4px;';
                            stateItem.appendChild(stateItemLabel);
                            const stateSelect = document.getElementById('policyStateFilter');
                            if (stateSelect) stateItem.appendChild(stateSelect);
                            filterPanel.appendChild(stateItem);

                            // Remove the original policyStateRow (includes unassigned toggle — no longer needed)
                            const stateRow = document.getElementById('policyStateRow');
                            if (stateRow) stateRow.remove();

                            // --- Move the main filter dropdowns container ---
                            const filtersContainer = document.getElementById('policyFiltersContainer');
                            if (filtersContainer) filterPanel.appendChild(filtersContainer);

                            // --- Reset Filters button (full width, at bottom) ---
                            const resetBtn = document.createElement('button');
                            resetBtn.className = 'reset-filters-sidebar-btn';
                            resetBtn.textContent = 'Reset Filters';
                            resetBtn.onclick = () => { if (typeof resetAllFilters === 'function') resetAllFilters(); };
                            filterPanel.appendChild(resetBtn);

                            // --- Bottom separator (mirrors the title separator) ---
                            const filterSep = document.createElement('div');
                            filterSep.className = 'sidebar-filter-bottom-sep';
                            filterPanel.appendChild(filterSep);
                        }

                        // Auto-expand the collapsible filter section (remove collapsed state)
                        const collapsible = document.getElementById('filtersCollapsibleContent');
                        const collapseIcon = document.getElementById('filtersCollapseIcon');
                        if (collapsible) {
                            collapsible.classList.remove('collapsed');
                            if (collapseIcon) collapseIcon.classList.remove('collapsed');
                        }

                        if (typeof filterPolicies === 'function') {
                            filterPolicies();
                        }
                    }, 100);
                } else {
                    throw new Error('No HTML content received from server');
                }
            } catch (error) {
                console.error('Error loading policies:', error);
                contentDiv.innerHTML = `<p style="color: #c00; text-align: center; padding: 40px;">❌ Failed to load policies: ${error.message}</p>`;
                showMessage('error', 'Failed to load policies: ' + error.message);
            }
        }
        
        async function refreshPolicyBrowser() {
            if (!authToken) {
                showMessage('error', 'Please authenticate first');
                showTokenModal();
                return;
            }
            
            showMessage('info', 'Refreshing policies...');
            await loadPoliciesIntoPolicyBrowser();
        }
        
        // ============================================================================
        // POLICY BROWSER FILTERING FUNCTIONS
        // ============================================================================
        
        // Copy object ID to clipboard
        function copyToClipboard(id, button) {
            event.stopPropagation();
            
            navigator.clipboard.writeText(id).then(() => {
                const feedback = button.querySelector('.copy-feedback');
                feedback.classList.add('show');
                setTimeout(() => feedback.classList.remove('show'), 1500);
            }).catch(err => {
                console.error('Failed to copy:', err);
                alert('Failed to copy ID to clipboard');
            });
        }
        
        // Toggle filters collapse/expand
        function toggleFiltersCollapse() {
            const content = document.getElementById('filtersCollapsibleContent');
            const icon = document.getElementById('filtersCollapseIcon');
            
            if (content && icon) {
                content.classList.toggle('collapsed');
                icon.classList.toggle('collapsed');
            }
        }
        
        // Reset all filters to default values
        function resetAllFilters() {
            document.getElementById('policyStateFilter').value = 'enabled';
            
            const filterIds = ['grantControlFilter', 'sessionControlFilter', 'resourceTypeFilter', 
                             'appliesToFilter', 'networkFilter', 'platformFilter', 'riskLevelFilter', 'clientAppTypeFilter', 'authFlowFilter'];
            
            filterIds.forEach(filterId => {
                const element = document.getElementById(filterId);
                if (element) {
                    const checkboxes = element.querySelectorAll('input[type="checkbox"]');
                    checkboxes.forEach(cb => cb.checked = false);
                    
                    const labelId = filterId.replace('Filter', 'Label');
                    const labelElement = document.getElementById(labelId);
                    if (labelElement) labelElement.innerHTML = 'Any';
                }
            });
            
            const unassignedFilter = document.getElementById('unassignedOnlyFilter');
            if (unassignedFilter) unassignedFilter.checked = false;
            
            const searchInput = document.getElementById('policySearch');
            if (searchInput) searchInput.value = '';
            
            filterPolicies();
        }
        
        // Toggle dropdown visibility
        function toggleDropdown(id) {
            const dropdown = document.getElementById(id);
            if (!dropdown) return;
            
            const button = dropdown.previousElementSibling;
            const container = dropdown.parentElement; // Get the .multi-select-dropdown container
            const isOpen = dropdown.classList.contains('show');
            
            // Close all dropdowns
            document.querySelectorAll('.multi-select-options').forEach(d => {
                d.classList.remove('show');
                if (d.previousElementSibling) d.previousElementSibling.classList.remove('active');
                if (d.parentElement) d.parentElement.classList.remove('open'); // Remove open class from dropdown container
                // Remove open class from parent card/section/container
                const parentCard = d.closest('.category-glass-card, .policy-count-section, .glassmorphism-container');
                if (parentCard) parentCard.classList.remove('open');
            });
            
            // Toggle current dropdown
            if (!isOpen) {
                dropdown.classList.add('show');
                if (button) button.classList.add('active');
                if (container) container.classList.add('open'); // Add open class to dropdown container for higher z-index
                // Add open class to parent card/section/container for even higher z-index
                const parentCard = dropdown.closest('.category-glass-card, .policy-count-section, .glassmorphism-container');
                if (parentCard) parentCard.classList.add('open');
            }
        }
        
        // Update filter label and trigger filtering
        function updateFilter(filterId) {
            const dropdown = document.getElementById(filterId);
            if (!dropdown) return;
            
            const checkboxes = dropdown.querySelectorAll('input[type="checkbox"]:checked');
            const count = checkboxes.length;
            const labelId = filterId.replace('Filter', 'Label');
            const label = document.getElementById(labelId);
            
            if (label) {
                if (count === 0) {
                    label.innerHTML = 'Any';
                } else if (count === 1) {
                    label.innerHTML = checkboxes[0].nextElementSibling.textContent;
                } else {
                    label.innerHTML = `${count} selected<span class="multi-select-count">${count}</span>`;
                }
            }
            
            filterPolicies();
        }
        
        function highlightSearchTerms(searchQuery) {
            const allPolicies = document.querySelectorAll('#policyCardsContainer .policy-card');
            allPolicies.forEach(policy => {
                const highlights = policy.querySelectorAll('.search-highlight');
                highlights.forEach(highlight => {
                    const parent = highlight.parentNode;
                    parent.replaceChild(document.createTextNode(highlight.textContent), highlight);
                    parent.normalize();
                });
            });
            
            if (!searchQuery) return;
            
            allPolicies.forEach(policy => {
                if (policy.style.display === 'none') return;
                highlightInElement(policy, searchQuery);
            });
        }
        
        function highlightInElement(element, searchQuery) {
            if (element.tagName === 'INPUT' || element.tagName === 'SCRIPT' || element.tagName === 'STYLE') {
                return;
            }
            
            const walker = document.createTreeWalker(
                element,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );
            
            const textNodes = [];
            let node;
            while (node = walker.nextNode()) {
                textNodes.push(node);
            }
            
            textNodes.forEach(textNode => {
                const text = textNode.textContent;
                const lowerText = text.toLowerCase();
                const index = lowerText.indexOf(searchQuery);
                
                if (index !== -1) {
                    const before = text.substring(0, index);
                    const match = text.substring(index, index + searchQuery.length);
                    const after = text.substring(index + searchQuery.length);
                    
                    const fragment = document.createDocumentFragment();
                    if (before) fragment.appendChild(document.createTextNode(before));
                    
                    const highlight = document.createElement('span');
                    highlight.className = 'search-highlight';
                    highlight.textContent = match;
                    fragment.appendChild(highlight);
                    
                    if (after) fragment.appendChild(document.createTextNode(after));
                    
                    textNode.parentNode.replaceChild(fragment, textNode);
                }
            });
        }
        
        function filterPolicies() {
            const stateFilter = document.getElementById('policyStateFilter');
            const searchInput = document.getElementById('policySearch');
            
            if (!stateFilter || !searchInput) return;
            
            const selectedState = stateFilter.value;
            const searchQuery = searchInput.value.toLowerCase().trim();
            
            const getCheckedValues = (filterId) => {
                const element = document.getElementById(filterId);
                if (!element) return [];
                return Array.from(element.querySelectorAll('input[type="checkbox"]:checked'))
                    .map(cb => cb.value);
            };
            
            const selectedGrantControls = getCheckedValues('grantControlFilter');
            const selectedSessionControls = getCheckedValues('sessionControlFilter');
            const selectedResourceTypes = getCheckedValues('resourceTypeFilter');
            const selectedAppliesTo = getCheckedValues('appliesToFilter');
            const selectedNetworks = getCheckedValues('networkFilter');
            const selectedPlatforms = getCheckedValues('platformFilter');
            const selectedRiskLevels = getCheckedValues('riskLevelFilter');
            const selectedClientAppTypes = getCheckedValues('clientAppTypeFilter');
            const selectedAuthFlows = getCheckedValues('authFlowFilter');
            
            const unassignedFilter = document.getElementById('unassignedOnlyFilter');
            const unassignedOnly = unassignedFilter ? unassignedFilter.checked : false;
            
            const allPolicies = document.querySelectorAll('#policyCardsContainer .policy-card');
            let visibleCount = 0;
            
            allPolicies.forEach(policy => {
                const policyState = policy.getAttribute('data-state');
                const isUnassigned = policy.getAttribute('data-unassigned') === 'true';
                const grantControls = policy.getAttribute('data-grant-controls') || '';
                const sessionControls = policy.getAttribute('data-session-controls') || '';
                const resourceTypes = policy.getAttribute('data-resource-types') || '';
                const appliesTo = policy.getAttribute('data-applies-to') || '';
                const networkTypes = policy.getAttribute('data-network-types') || '';
                const platforms = policy.getAttribute('data-platforms') || '';
                const riskLevels = policy.getAttribute('data-risk-levels') || '';
                const clientAppTypes = policy.getAttribute('data-client-app-types') || '';
                const authFlows = policy.getAttribute('data-auth-flows') || '';
                
                const stateMatch = (selectedState === 'all' || policyState === selectedState);
                const grantMatch = (selectedGrantControls.length === 0 || 
                    selectedGrantControls.some(control => grantControls.includes(control)));
                const sessionMatch = (selectedSessionControls.length === 0 || 
                    selectedSessionControls.some(control => sessionControls.includes(control)));
                const resourceMatch = (selectedResourceTypes.length === 0 || 
                    selectedResourceTypes.some(type => resourceTypes.includes(type)));
                const appliesToMatch = (selectedAppliesTo.length === 0 || 
                    selectedAppliesTo.some(type => appliesTo.includes(type)));
                const networkMatch = (selectedNetworks.length === 0 || 
                    selectedNetworks.some(network => networkTypes.includes(network)));
                const platformMatch = (selectedPlatforms.length === 0 || 
                    selectedPlatforms.some(platform => platforms.includes(platform)));
                const riskLevelMatch = (selectedRiskLevels.length === 0 || 
                    selectedRiskLevels.some(risk => riskLevels.includes(risk)));
                const clientAppTypeMatch = (selectedClientAppTypes.length === 0 || 
                    selectedClientAppTypes.some(type => clientAppTypes.includes(type)));
                
                // Authentication Flows filter: if selected, policy must have auth flows section with matching transfer method
                let authFlowMatch = true;
                if (selectedAuthFlows.length > 0) {
                    // Policy must have at least one of the selected auth flows
                    authFlowMatch = selectedAuthFlows.some(flow => authFlows.includes(flow));
                }
                
                const unassignedMatch = !unassignedOnly || isUnassigned;
                const searchMatch = !searchQuery || policy.textContent.toLowerCase().includes(searchQuery);
                
                if (stateMatch && grantMatch && sessionMatch && resourceMatch && 
                    appliesToMatch && networkMatch && platformMatch && riskLevelMatch && 
                    clientAppTypeMatch && authFlowMatch && unassignedMatch && searchMatch) {
                    policy.style.display = 'block';
                    visibleCount++;
                } else {
                    policy.style.display = 'none';
                }
            });
            
            highlightSearchTerms(searchQuery);
            
            const countElement = document.getElementById('policyBrowserCount');
            if (countElement) {
                countElement.textContent = `Showing ${visibleCount} of ${allPolicies.length} policies`;
            }
        }
        
        // Close dropdowns when clicking outside
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.multi-select-dropdown')) {
                document.querySelectorAll('.multi-select-options').forEach(d => {
                    d.classList.remove('show');
                    if (d.previousElementSibling) d.previousElementSibling.classList.remove('active');
                });
            }
        });
        
        // ============================================================================
        // END POLICY BROWSER FILTERING FUNCTIONS
        // ============================================================================
        
        let currentPage = 1; // Current page number for gap detail pagination
        let totalGaps = 0; // Total number of gaps (for pagination)
        const pageSize = 20; // Results per page
        let totalResults = 0; // For aggregated view pagination
        let currentView = 'aggregated'; // 'aggregated' or 'detail'
        let selectedUser = null;
        let currentUserGaps = []; // Store current page of gaps
        let currentFilterValues = null; // Pre-fetched filter values for all dimensions
        let activeFilters = {}; // Store active filter selections
        let activeIdentityTypes = new Set(); // Store enabled identity type filters
        let allUsers = []; // Store all users for client-side filtering
        let showCriticalGapsOnly = false; // Filter to show only identities with universal gaps
        
        // Format number with space as thousands separator
        function formatNumber(num) {
            return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ' ');
        }
        
        // Upload box drag and drop
        const uploadBox = document.getElementById('uploadBox');
        
        uploadBox.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadBox.classList.add('dragover');
        });
        
        uploadBox.addEventListener('dragleave', () => {
            uploadBox.classList.remove('dragover');
        });
        
        uploadBox.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadBox.classList.remove('dragover');
            
            const files = e.dataTransfer.files;
            if (files.length > 0 && files[0].name.endsWith('.json')) {
                uploadFileData(files[0]);
            } else {
                showMessage('error', 'Please drop a valid JSON file');
            }
        });
        
        function uploadFile() {
            const fileInput = document.getElementById('fileInput');
            if (fileInput.files.length > 0) {
                uploadFileData(fileInput.files[0]);
            }
        }
        
        function uploadFileData(file) {
            const formData = new FormData();
            formData.append('file', file);
            
            // Include authentication token if available (for tenant domain lookup)
            if (authToken) {
                formData.append('token', authToken);
            }
            
            // Show progress container
            const progressContainer = document.getElementById('progressContainer');
            const progressBar = document.getElementById('progressBar');
            const progressPercent = document.getElementById('progressPercent');
            const progressLabel = document.getElementById('progressLabel');
            
            progressContainer.classList.remove('hidden');
            progressBar.style.width = '0%';
            progressPercent.textContent = '0%';
            progressLabel.textContent = 'Uploading...';
            
            const xhr = new XMLHttpRequest();
            
            // Track upload progress
            xhr.upload.addEventListener('progress', (e) => {
                if (e.lengthComputable) {
                    const uploadPercent = Math.round((e.loaded / e.total) * 50); // Upload is 0-50%
                    progressBar.style.width = uploadPercent + '%';
                    progressPercent.textContent = uploadPercent + '%';
                }
            });
            
            // Handle completion
            xhr.addEventListener('load', async () => {
                if (xhr.status === 200) {
                    // Upload complete, now importing to database (50-100%)
                    progressLabel.textContent = 'Importing to database...';
                    
                    // Animate progress from 50% to 100%
                    let currentProgress = 50;
                    const importInterval = setInterval(() => {
                        currentProgress += 5;
                        if (currentProgress <= 100) {
                            progressBar.style.width = currentProgress + '%';
                            progressPercent.textContent = currentProgress + '%';
                        } else {
                            clearInterval(importInterval);
                        }
                    }, 100);
                    
                    try {
                        const data = JSON.parse(xhr.responseText);
                        
                        if (data.success) {
                            clearInterval(importInterval);
                            progressBar.style.width = '100%';
                            progressPercent.textContent = '100%';
                            progressLabel.textContent = 'Import complete!';
                            
                            setTimeout(() => {
                                progressContainer.classList.add('hidden');
                            }, 1500);
                            
                            currentRunId = data.run_id;
                            showMessage('success', `✓ Analysis imported successfully (Run #${data.run_id})`);
                            await loadAnalysis();
                            await loadScanHistory(); // Refresh sidebar tenant submenus
                            // Redirect to the matching tenant submenu
                            const tenantId = currentAnalysisMetadata &&
                                (currentAnalysisMetadata.tenant_id || currentAnalysisMetadata.tenantId);
                            if (tenantId && window.allScansByTenant && window.allScansByTenant[tenantId]) {
                                const tenantData = window.allScansByTenant[tenantId];
                                const fullName = tenantData.tenantDomain
                                    ? tenantData.tenantDomain.toLowerCase() : tenantId;
                                const displayName = fullName.length > 50
                                    ? fullName.slice(0, 50) + '\u2026' : fullName;
                                const subBtn = document.querySelector(
                                    `.sidebar-nav-subitem[onclick*="'${tenantId}'"]`);
                                showTenantHistory(tenantId, displayName, subBtn);
                                setTimeout(() => {
                                    const statsEl = document.getElementById('statsSection');
                                    if (statsEl && !statsEl.classList.contains('hidden')) {
                                        statsEl.scrollIntoView({ behavior: 'smooth', block: 'start' });
                                    }
                                }, 150);
                            }
                        } else {
                            clearInterval(importInterval);
                            progressContainer.classList.add('hidden');
                            showMessage('error', `Upload failed: ${data.error}`);
                        }
                    } catch (error) {
                        clearInterval(importInterval);
                        progressContainer.classList.add('hidden');
                        showMessage('error', `Parse error: ${error.message}`);
                    }
                } else {
                    progressContainer.classList.add('hidden');
                    showMessage('error', `Upload failed with status ${xhr.status}`);
                }
            });
            
            // Handle errors
            xhr.addEventListener('error', () => {
                progressContainer.classList.add('hidden');
                showMessage('error', 'Upload error: Network failure');
            });
            
            // Handle abort
            xhr.addEventListener('abort', () => {
                progressContainer.classList.add('hidden');
                showMessage('error', 'Upload cancelled');
            });
            
            // Send the request
            xhr.open('POST', `${API_BASE}/api/upload`, true);
            xhr.send(formData);
        }
        
        async function loadAnalysis() {
            if (!currentRunId) return;
            
            try {
                // Load summary
                const summaryResponse = await fetch(`${API_BASE}/api/runs/${currentRunId}/summary`);
                const summaryData = await summaryResponse.json();
                
                // Store analysis metadata for later use (e.g., formatting filters)
                currentAnalysisMetadata = summaryData.run;
                
                // Update scan configuration banner
                updateScanConfigBanner(currentAnalysisMetadata);
                
                // Update workload/agent identities grant control banner
                updateWorkloadGrantControlBanner(currentAnalysisMetadata);
                
                // Update statistics
                const run = summaryData.run;
                const totalIdentities = run.total_identities || 0;
                
                // Calculate absolute values from percentages (now mutually exclusive)
                const mfaCovered = run.mfa_coverage_pct != null ? Math.round(totalIdentities * run.mfa_coverage_pct / 100) : 0;
                const authStrengthCovered = run.auth_strength_coverage_pct != null ? Math.round(totalIdentities * run.auth_strength_coverage_pct / 100) : 0;
                const blockCovered = run.block_coverage_pct != null ? Math.round(totalIdentities * run.block_coverage_pct / 100) : 0;
                
                // Get actual identities with gaps from analysis results (not calculated from coverage)
                const identitiesWithGaps = run.identities_with_gaps || 0;
                
                // Calculate raw percentages
                let mfaPct = run.mfa_coverage_pct || 0;
                let authStrengthPct = run.auth_strength_coverage_pct || 0;
                let blockPct = run.block_coverage_pct || 0;
                let gapPct = totalIdentities > 0 ? ((identitiesWithGaps / totalIdentities) * 100) : 0;
                
                // Normalize percentages to ensure they sum to exactly 100%
                // This prevents rounding errors that cause totals like 100.1% or 99.9%
                const rawSum = mfaPct + authStrengthPct + blockPct + gapPct;
                if (rawSum > 0 && rawSum !== 100) {
                    const scaleFactor = 100 / rawSum;
                    mfaPct *= scaleFactor;
                    authStrengthPct *= scaleFactor;
                    blockPct *= scaleFactor;
                    gapPct *= scaleFactor;
                }
                
                // Round to 1 decimal place
                mfaPct = Math.round(mfaPct * 10) / 10;
                authStrengthPct = Math.round(authStrengthPct * 10) / 10;
                blockPct = Math.round(blockPct * 10) / 10;
                gapPct = Math.round(gapPct * 10) / 10;
                
                // CRITICAL: If there are actual gaps but percentage rounded to 0, set to 0.1% minimum
                // This ensures gaps are always visible when they exist
                if (identitiesWithGaps > 0 && gapPct === 0) {
                    gapPct = 0.1;
                }
                
                // Adjust percentages to ensure exact 100% sum after gap minimum applied
                const roundedSum = mfaPct + authStrengthPct + blockPct + gapPct;
                if (roundedSum !== 100 && roundedSum > 0) {
                    const diff = 100 - roundedSum;
                    // Apply difference to the largest non-gap percentage to minimize visual impact
                    if (blockPct > 0 && (blockPct >= mfaPct && blockPct >= authStrengthPct)) {
                        blockPct = Math.round((blockPct + diff) * 10) / 10;
                    } else if (authStrengthPct > 0 && (authStrengthPct >= mfaPct)) {
                        authStrengthPct = Math.round((authStrengthPct + diff) * 10) / 10;
                    } else if (mfaPct > 0) {
                        mfaPct = Math.round((mfaPct + diff) * 10) / 10;
                    } else if (gapPct > 0) {
                        // Only adjust gap if it's the only non-zero value
                        gapPct = Math.round((gapPct + diff) * 10) / 10;
                    }
                }
                
                // Calculate overall coverage (sum of MFA + Auth Strength + Block)
                let overallCovered = mfaCovered + authStrengthCovered + blockCovered;
                let overallPct = mfaPct + authStrengthPct + blockPct;
                
                // Special case: if no gaps exist but no coverage is recorded, treat as 100% coverage
                // This handles scenarios where all policies are excluded but analysis found no gaps
                if (identitiesWithGaps === 0 && totalIdentities > 0 && overallPct === 0) {
                    overallPct = 100;
                    overallCovered = totalIdentities;  // All identities are covered
                }
                
                // Update raw counts
                document.getElementById('countGaps').textContent = formatNumber(identitiesWithGaps);
                document.getElementById('countMfa').textContent = formatNumber(mfaCovered);
                document.getElementById('countAuthStrength').textContent = formatNumber(authStrengthCovered);
                document.getElementById('countBlock').textContent = formatNumber(blockCovered);
                document.getElementById('countOverallCoverage').textContent = formatNumber(overallCovered);
                
                // Update excluded policies count in scan config banner
                document.getElementById('scanConfigExcludedCount').textContent = formatNumber(run.excluded_policies_count || 0);
                
                // Update filter statistics (included/excluded users) - show only relevant cards
                const includedUsers = run.included_users_count;
                const excludedUsers = run.excluded_users_count;
                const totalIdentitiesInTenant = run.total_identities_in_tenant;
                
                // Check if filter statistics are available (new scan format)
                const hasFilterStats = totalIdentitiesInTenant !== undefined && totalIdentitiesInTenant !== null;

                // Fallback: detect filter usage from filter config fields when stats aren't available.
                // include_object_ids / skip_object_ids are stored as JSON-serialised flat arrays of GUIDs.
                const _parseRunHasIds = (raw) => {
                    try {
                        if (!raw) return false;
                        const v = JSON.parse(raw);
                        if (Array.isArray(v)) return v.length > 0;
                        return Object.values(v).some(a => Array.isArray(a) && a.length > 0);
                    } catch { return false; }
                };
                const _runHasInclude = _parseRunHasIds(run.include_object_ids);
                const _runHasExclude = _parseRunHasIds(run.skip_object_ids);
                
                if (hasFilterStats) {
                    // Determine if filters were actually used
                    const hasIncludeFilter = includedUsers !== totalIdentitiesInTenant;
                    const hasExcludeFilter = excludedUsers > 0;
                    
                    // Show Included Identities card if filters were used
                    if (hasIncludeFilter || hasExcludeFilter) {
                        document.getElementById('scanConfigIncludedUsers').textContent = `${formatNumber(includedUsers)}/${formatNumber(totalIdentitiesInTenant)}`;
                        document.getElementById('scanConfigIncludedUsersItem').style.display = 'flex';
                    } else {
                        // No filters used - hide the card
                        document.getElementById('scanConfigIncludedUsersItem').style.display = 'none';
                    }
                    
                    // Show Excluded Identities card only if identities were excluded
                    if (hasExcludeFilter) {
                        document.getElementById('scanConfigExcludedUsers').textContent = `${formatNumber(excludedUsers)}/${formatNumber(totalIdentitiesInTenant)}`;
                        document.getElementById('scanConfigExcludedUsersItem').style.display = 'flex';
                    } else {
                        document.getElementById('scanConfigExcludedUsersItem').style.display = 'none';
                    }
                } else {
                    // No stats yet — fall back to filter config fields if available
                    if (_runHasInclude) {
                        document.getElementById('scanConfigIncludedUsers').textContent = 'Filter applied';
                        document.getElementById('scanConfigIncludedUsersItem').style.display = 'flex';
                    } else {
                        document.getElementById('scanConfigIncludedUsersItem').style.display = 'none';
                    }
                    if (_runHasExclude) {
                        document.getElementById('scanConfigExcludedUsers').textContent = 'Filter applied';
                        document.getElementById('scanConfigExcludedUsersItem').style.display = 'flex';
                    } else {
                        document.getElementById('scanConfigExcludedUsersItem').style.display = 'none';
                    }
                }
                
                // Format and update analysis duration
                const durationSeconds = run.analysis_duration_seconds;
                let durationText = '-';
                if (durationSeconds !== undefined && durationSeconds !== null) {
                    if (durationSeconds < 60) {
                        durationText = `${Math.round(durationSeconds)}s`;
                    } else if (durationSeconds < 3600) {
                        const minutes = Math.floor(durationSeconds / 60);
                        const seconds = Math.round(durationSeconds % 60);
                        durationText = `${minutes}m ${seconds}s`;
                    } else {
                        const hours = Math.floor(durationSeconds / 3600);
                        const minutes = Math.floor((durationSeconds % 3600) / 60);
                        durationText = `${hours}h ${minutes}m`;
                    }
                }
                document.getElementById('scanConfigDuration').textContent = durationText;
                
                // Update percentages
                document.getElementById('statTotalIdentities').textContent = `${gapPct}%`;
                document.getElementById('statMfaCoverage').textContent = `${mfaPct}%`;
                document.getElementById('statAuthStrengthCoverage').textContent = `${authStrengthPct}%`;
                document.getElementById('statBlockCoverage').textContent = `${blockPct}%`;
                document.getElementById('statOverallCoverage').textContent = `${overallPct.toFixed(1)}%`;
                
                // Animate progress bars
                setTimeout(() => {
                    document.getElementById('progressGaps').style.width = `${gapPct}%`;
                    document.getElementById('progressMfa').style.width = `${mfaPct}%`;
                    document.getElementById('progressAuthStrength').style.width = `${authStrengthPct}%`;
                    document.getElementById('progressBlock').style.width = `${blockPct}%`;
                    document.getElementById('progressOverallCoverage').style.width = `${overallPct}%`;
                }, 100);
                
                // Show results section (upload area stays visible)
                document.getElementById('statsSection').classList.remove('hidden');
                document.getElementById('resultsSection').classList.remove('hidden');
                
                // Reset to aggregated view
                currentView = 'aggregated';
                selectedUser = null;
                activeIdentityTypes.clear(); // Clear previous filter state
                showCriticalGapsOnly = false; // Reset critical gaps filter
                
                // Load aggregated user data
                await loadAggregatedUsers();
            } catch (error) {
                showMessage('error', `Failed to load analysis: ${error.message}`);
            }
        }
        
        async function loadAggregatedUsers() {
            try {
                const response = await fetch(`${API_BASE}/api/runs/${currentRunId}/users`);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                const data = await response.json();
                
                totalResults = data.total_users || 0;
                
                // Store all users for filtering
                allUsers = data.users || [];
                
                // Initialize identity type filters based on available types
                const uniqueTypes = [...new Set(allUsers.map(u => u.user_type))];
                uniqueTypes.forEach(type => activeIdentityTypes.add(type));
                
                renderAggregatedUsers(allUsers);
                
                // Hide pagination for aggregated view
                const paginationEl = document.querySelector('.pagination');
                if (paginationEl) {
                    paginationEl.style.display = 'none';
                }
            } catch (error) {
                showMessage('error', `Failed to load users: ${error.message}`);
                console.error('Error in loadAggregatedUsers:', error);
                // Render empty state on error
                renderAggregatedUsers([]);
            }
        }
        
        async function loadUserDetails(userId, userName) {
            currentView = 'detail';
            selectedUser = { id: userId, name: userName };
            currentPage = 1;
            activeFilters = {}; // Reset filters
            
            try {
                // First, fetch all available filter values (not paginated)
                const filterValuesParams = new URLSearchParams({
                    user_id: userId,
                    type: 'gaps'
                });
                
                const filterValuesResponse = await fetch(`${API_BASE}/api/runs/${currentRunId}/filter-values?${filterValuesParams}`);
                const filterValues = await filterValuesResponse.json();
                currentFilterValues = filterValues;  // Store for building filters
                
                // Then fetch the first page of gaps (20 results)
                await loadUserGapsPage(1);
                
            } catch (error) {
                showMessage('error', `Failed to load user details: ${error.message}`);
            }
        }
        
        async function loadUserGapsPage(page) {
            // Load a specific page of gaps with current filters applied
            if (!selectedUser) return;
            
            try {
                const offset = (page - 1) * pageSize;
                
                // Build query parameters
                const params = new URLSearchParams({
                    user_id: selectedUser.id,
                    type: 'gaps',
                    limit: pageSize,
                    offset: offset
                });
                
                // Add active filters to query
                if (activeFilters.client_app_type) {
                    params.append('client_app_type', activeFilters.client_app_type);
                }
                if (activeFilters.location_name) {
                    params.append('location_name', activeFilters.location_name);
                }
                if (activeFilters.resource_app_name) {
                    params.append('resource_app_name', activeFilters.resource_app_name);
                }
                
                const response = await fetch(`${API_BASE}/api/runs/${currentRunId}/permutations?${params}`);
                const data = await response.json();
                
                // Store current page data
                currentUserGaps = data.results;
                totalGaps = data.total;
                currentPage = page;
                
                // Render the page
                renderUserDetails(currentUserGaps, selectedUser.name);
                
            } catch (error) {
                showMessage('error', `Failed to load page: ${error.message}`);
            }
        }
        
        function updateScanConfigBanner(metadata) {
            // Update identity type
            const assignments = metadata.assignments || 'users';
            const identityIconEl = document.getElementById('scanConfigIdentityIcon');
            const identityTypeEl = document.getElementById('scanConfigIdentityType');
            
            if (assignments === 'users') {
                identityIconEl.textContent = '👤';
                identityTypeEl.textContent = 'Member Users';
            } else if (assignments === 'guests') {
                identityIconEl.textContent = '💼';
                identityTypeEl.textContent = 'Guest and External Users';
            } else if (assignments === 'agent-identities') {
                identityIconEl.textContent = '🤖';
                identityTypeEl.textContent = 'Agent Identities';
            } else if (assignments === 'workload-identities') {
                identityIconEl.textContent = '🚀';
                identityTypeEl.textContent = 'Workload Identities';
            }
            
            // Update target resource type
            const targetResources = metadata.target_resources || 'cloud-apps';
            const resourceIconEl = document.getElementById('scanConfigResourceIcon');
            const resourceTypeEl = document.getElementById('scanConfigResourceType');
            
            if (targetResources === 'cloud-apps') {
                resourceIconEl.textContent = '📱';
                resourceTypeEl.textContent = 'Cloud Applications';
            } else if (targetResources === 'user-actions') {
                resourceIconEl.textContent = '👆';
                resourceTypeEl.textContent = 'User Actions';
            } else if (targetResources === 'agent-resources') {
                resourceIconEl.textContent = '🤖';
                resourceTypeEl.textContent = 'Agent Resources';
            }
        }
        
        function updateWorkloadGrantControlBanner(metadata) {
            const banner = document.getElementById('workloadGrantControlBanner');
            const identityTypeEl = document.getElementById('workloadGrantControlIdentityType');
            const assignments = metadata.assignments || 'users';
            
            // Show banner only for agent-identities or workload-identities
            if (assignments === 'agent-identities') {
                identityTypeEl.textContent = 'Agent Identities';
                banner.classList.add('visible');
            } else if (assignments === 'workload-identities') {
                identityTypeEl.textContent = 'Workload Identities';
                banner.classList.add('visible');
            } else {
                banner.classList.remove('visible');
            }
        }
                
        function capitalizeValue(value) {
            // Capitalize first letter of each word
            if (!value) return value;
            return value.split(' ').map(word => 
                word.charAt(0).toUpperCase() + word.slice(1)
            ).join(' ');
        }
        
        function getFormattedClientAppType(clientType) {
            // Format client app type values with proper capitalization
            const mappings = {
                'browser': 'Browser',
                'mobileAppsAndDesktopClients': 'Mobile Apps And Desktop Clients',
                'exchangeActiveSync': 'Exchange ActiveSync',
                'other': 'Other (Legacy)',
                'all': 'Any'
            };
            return mappings[clientType] || capitalizeValue(clientType);
        }
        
        function getFormattedDisplayValue(value, capitalize = false) {
            // Map common values to user-friendly display names
            if (value === 'all') {
                return 'Any';
            }
            if (value === 'unknownFutureValue') {
                return 'Unknown';
            }
            if (capitalize) {
                return capitalizeValue(value);
            }
            return value;
        }
        
        function buildPaginationControls(page, totalPages, totalResults) {
            if (totalPages <= 1) return ''; // No pagination needed
            
            const startResult = (page - 1) * pageSize + 1;
            const endResult = Math.min(page * pageSize, totalResults);
            
            // Build page number buttons (show current, prev 2, next 2)
            let pageButtons = [];
            const minPage = Math.max(1, page - 2);
            const maxPage = Math.min(totalPages, page + 2);
            
            // Add first page if not in range
            if (minPage > 1) {
                pageButtons.push(`<button class="page-btn" onclick="loadUserGapsPage(1)">1</button>`);
                if (minPage > 2) {
                    pageButtons.push(`<span class="page-ellipsis">...</span>`);
                }
            }
            
            // Add page range
            for (let i = minPage; i <= maxPage; i++) {
                const activeClass = i === page ? 'active' : '';
                pageButtons.push(`<button class="page-btn ${activeClass}" onclick="loadUserGapsPage(${i})">${i}</button>`);
            }
            
            // Add last page if not in range
            if (maxPage < totalPages) {
                if (maxPage < totalPages - 1) {
                    pageButtons.push(`<span class="page-ellipsis">...</span>`);
                }
                pageButtons.push(`<button class="page-btn" onclick="loadUserGapsPage(${totalPages})">${totalPages}</button>`);
            }
            
            return `
                <div class="pagination-controls">
                    <button class="pagination-nav" onclick="loadUserGapsPage(${page - 1})" ${page <= 1 ? 'disabled' : ''}>
                        ← Previous
                    </button>
                    <div class="pagination-info">
                        <span class="result-range">Showing ${startResult}-${endResult} of ${totalResults}</span>
                        <div class="page-numbers">
                            ${pageButtons.join('')}
                        </div>
                    </div>
                    <button class="pagination-nav" onclick="loadUserGapsPage(${page + 1})" ${page >= totalPages ? 'disabled' : ''}>
                        Next →
                    </button>
                </div>
            `;
        }
        
        function buildDynamicFiltersHTML(gaps) {
            // Use pre-fetched filter values if available, otherwise extract from gaps
            const filterSource = currentFilterValues || null;
            
            // Define dimension mappings (field name -> display label)
            // Order matches the access path display order
            const dimensions = [
                { field: 'client_app_type', label: 'Client App Types', capitalize: true, filterKey: 'client_app_types' },
                { field: 'auth_flow', label: 'Authentication Flows', capitalize: true, filterKey: 'auth_flows' },
                { field: 'location_name', label: 'Locations', capitalize: true, filterKey: 'locations' },
                { field: 'resource_app_name', label: 'Target Resources', capitalize: true, filterKey: 'resource_apps' }
            ];
            
            let filtersHTML = [];
            
            dimensions.forEach(dim => {
                let uniqueValues = [];
                
                // Get unique values from pre-fetched filter values or extract from gaps
                if (filterSource && filterSource[dim.filterKey]) {
                    uniqueValues = filterSource[dim.filterKey];
                } else {
                    // Fallback: extract from gaps (may be incomplete if paginated)
                    uniqueValues = [...new Set(
                        gaps.map(gap => gap[dim.field])
                            .filter(val => val != null && val !== '')
                    )];
                }
                
                // Only create filter if there are values for this dimension
                if (uniqueValues.length > 0) {
                    // Separate "all" values from others
                    const anyValues = uniqueValues.filter(val => val.toLowerCase() === 'all' || val.toLowerCase() === 'alltrusted');
                    const otherValues = uniqueValues.filter(val => val.toLowerCase() !== 'all' && val.toLowerCase() !== 'alltrusted');
                    
                    // Sort locations alphabetically; others sort naturally
                    if (dim.field === 'location_name') {
                        otherValues.sort((a, b) => a.localeCompare(b));
                    } else {
                        otherValues.sort();
                    }
                    
                    // Check if this dimension has an active filter
                    const selectedValue = activeFilters[dim.field] || '';
                    
                    const options = [`<option value=""${selectedValue === '' ? ' selected' : ''}>No Filter</option>`];
                    
                    // Add "Any" options first (right after "No Filter")
                    anyValues.forEach(value => {
                        const selected = value === selectedValue ? ' selected' : '';
                        let displayValue = value;
                        if (dim.field === 'resource_app_name') {
                            // Special handling for "Any" in Target Resources - show context
                            displayValue = 'Any';
                        } else if (value.toLowerCase() === 'alltrusted') {
                            // Show "All Trusted" for the alltrusted location
                            displayValue = 'All Trusted';
                        } else {
                            // Convert "all" to "Any" for all other dimensions (including locations)
                            displayValue = 'Any';
                        }
                        options.push(`<option value="${value}"${selected}>${displayValue}</option>`);
                    });
                    
                    // Then add other values
                    otherValues.forEach(value => {
                        const selected = value === selectedValue ? ' selected' : '';
                        // Get appropriate display value
                        let displayValue = value;
                        if (dim.field === 'client_app_type') {
                            displayValue = getFormattedClientAppType(value);
                        } else if (dim.capitalize) {
                            displayValue = capitalizeValue(value);
                        }
                        options.push(`<option value="${value}"${selected}>${displayValue}</option>`);
                    });
                    
                    filtersHTML.push(`
                        <div class="filter-group">
                            <label for="filter_${dim.field}">${dim.label}</label>
                            <select id="filter_${dim.field}" class="filter-select" onchange="applyDetailFilters()">
                                ${options.join('')}
                            </select>
                        </div>
                    `);
                }
            });
            
            if (filtersHTML.length > 0) {
                return `
                    <div class="filters-section" style="margin-top: 1rem;">
                        <div class="filters-grid">
                            ${filtersHTML.join('')}
                        </div>
                    </div>
                `;
            }
            
            return '';
        }
        
        async function applyDetailFilters() {
            // Collect all active filters
            const filterSelects = document.querySelectorAll('.filter-select');
            activeFilters = {};
            
            filterSelects.forEach(select => {
                if (select.value) {
                    const field = select.id.replace('filter_', '');
                    activeFilters[field] = select.value;
                }
            });
            
            // Reset to page 1 and fetch filtered results from server
            await loadUserGapsPage(1);
        }
        
        function backToAggregated() {
            currentView = 'aggregated';
            selectedUser = null;
            currentUserGaps = [];
            activeFilters = {};
            
            // Apply existing filters instead of reloading all users
            // This preserves the critical gaps toggle and identity type filters
            applyAggregatedFilters();
        }
        
        function toggleIdentityType(type) {
            // Toggle the identity type in the active set
            if (activeIdentityTypes.has(type)) {
                activeIdentityTypes.delete(type);
            } else {
                activeIdentityTypes.add(type);
            }
            
            // Apply all filters and re-render
            applyAggregatedFilters();
        }
        
        function toggleCriticalGapsFilter() {
            // Toggle critical gaps filter
            showCriticalGapsOnly = !showCriticalGapsOnly;
            
            // Apply all filters and re-render
            applyAggregatedFilters();
        }
        
        function applyAggregatedFilters() {
            // Apply identity type filters
            let filteredUsers = allUsers.filter(user => activeIdentityTypes.has(user.user_type));
            
            // Apply critical gaps filter if active
            if (showCriticalGapsOnly) {
                filteredUsers = filteredUsers.filter(user => user.is_universal_gap === true);
            }
            
            renderAggregatedUsers(filteredUsers);
        }
        
        function renderAggregatedUsers(users) {
            const grid = document.getElementById('resultsGrid');
            
            // Build identity type filters if there are multiple types in the original dataset
            const allUniqueTypes = [...new Set(allUsers.map(u => u.user_type))];
            let identityTypeFiltersHTML = '';
            
            // Count display for number of identities shown
            const identityCountHTML = `
                <span style="font-weight: 600; color: #0078d4; font-size: 14px; white-space: nowrap;">
                    Showing ${users.length} ${users.length === 1 ? 'identity' : 'identities'}
                </span>
            `;
            
            // Always show critical gaps toggle
            let criticalGapsToggleHTML = `
                <div class="identity-type-checkbox" style="margin-left: auto; border-left: 2px solid rgba(255,255,255,0.2); padding-left: 1rem;">
                    <input 
                        type="checkbox" 
                        id="type_critical_gaps" 
                        ${showCriticalGapsOnly ? 'checked' : ''}
                        onchange="toggleCriticalGapsFilter()"
                    />
                    <label for="type_critical_gaps" style="color: #ff6b35; font-weight: 600;">⚠️ Critical Gaps Only</label>
                </div>
            `;
            
            if (allUniqueTypes.length > 1) {
                // Define display information for each identity type
                const typeInfo = {
                    'user': { label: 'Users', icon: '👤' },
                    'group': { label: 'Groups', icon: '👤' },
                    'role': { label: 'Entra Roles', icon: '🎭' },
                    'agent_identity': { label: 'Agents', icon: '🤖' },
                    'workload_identity': { label: 'Workload Identities', icon: '🚀' }
                };
                
                const checkboxes = allUniqueTypes.map(type => {
                    const info = typeInfo[type] || { label: type, icon: '❓' };
                    const isChecked = activeIdentityTypes.has(type);
                    return `
                        <div class="identity-type-checkbox">
                            <input 
                                type="checkbox" 
                                id="type_${type}" 
                                ${isChecked ? 'checked' : ''}
                                onchange="toggleIdentityType('${type}')"
                            />
                            <label for="type_${type}">${info.icon} ${info.label}</label>
                        </div>
                    `;
                }).join('');
                
                identityTypeFiltersHTML = `
                    <div class="identity-type-filters">
                        ${identityCountHTML}
                        <span class="identity-type-filters-label" style="margin-left: 1.5rem;">Filter by Identity Type:</span>
                        ${checkboxes}
                        ${criticalGapsToggleHTML}
                    </div>
                `;
            } else {
                // Show only critical gaps toggle when single identity type
                identityTypeFiltersHTML = `
                    <div class="identity-type-filters">
                        ${identityCountHTML}
                        ${criticalGapsToggleHTML}
                    </div>
                `;
            }
            
            // Handle empty state but keep identity type filters visible
            let userCardsHTML = '';
            if (users.length === 0) {
                userCardsHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">📭</div>
                        <div class="empty-state-text">No results match the selected filters</div>
                        <p>Try selecting different identity types</p>
                    </div>
                `;
            } else {
                userCardsHTML = users.map((user) => {
                    // Determine icon and label based on identity type
                    let icon = '👤'; // default user icon
                    let typeLabel = 'Member User';
                
                // Set icon and label based on user type
                if (user.user_type === 'group') {
                    icon = '👤';
                    typeLabel = 'group';
                } else if (user.user_type === 'role') {
                    icon = '🎭';
                    typeLabel = 'Entra Role';
                } else if (user.user_type === 'agent_identity') {
                    icon = '🤖';
                    typeLabel = 'agent';
                } else if (user.user_type === 'workload_identity') {
                    icon = '🚀';
                    typeLabel = 'Workload Identity';
                } else if (user.user_type === 'guest' || user.user_type === 'guests' || user.user_type === 'internal-guests') {
                    icon = '💼';
                    typeLabel = 'guest user';
                }
                
                // Set display name - show "Any" if user_id is 'all'
                let displayName = user.user_display_name || 'Unknown Identity';
                if (user.user_id === 'all' || (user.user_display_name && user.user_display_name.toLowerCase() === 'all')) {
                    displayName = 'Any';
                    // Update icon to warning for critical gaps affecting all
                    icon = '⚠️';
                }
                
                return `
                <div class="user-card" onclick="loadUserDetails('${user.user_id}', '${displayName.replace(/'/g, "\\'")}')">
                    <div class="user-card-header">
                        <div class="user-name">
                            ${icon} ${displayName}
                            <span class="user-type-badge">${typeLabel}</span>
                            ${user.is_universal_gap ? '<span class="user-type-badge" style="background: #ff6b35; color: white; font-weight: 700; border: 1px solid rgba(255,107,53,0.3); box-shadow: 0 2px 8px rgba(255,107,53,0.3);">⚠️ CRITICAL - Universal Gap</span>' : ''}
                            ${user.user_type === 'group' && user.user_count ? `<span style="background: #0078d4; color: white; padding: 2px 8px; border-radius: 12px; font-size: 11px; font-weight: 600; margin-left: 8px;">${user.user_count} users</span>` : ''}
                        </div>
                        <div class="gap-count">${user.gap_count}</div>
                    </div>
                    <div class="user-stats">
                        <div class="user-stat">
                            <div class="user-stat-value">${user.unique_client_types}</div>
                            <div class="user-stat-label">Client App Types</div>
                        </div>
                        <div class="user-stat">
                            <div class="user-stat-value">${user.unique_locations}</div>
                            <div class="user-stat-label">Locations</div>
                        </div>
                        <div class="user-stat">
                            <div class="user-stat-value">${user.unique_apps}</div>
                            <div class="user-stat-label">${currentAnalysisMetadata && currentAnalysisMetadata.target_resources === 'user-actions' ? 'User Actions' : currentAnalysisMetadata && currentAnalysisMetadata.target_resources === 'agent-resources' ? 'Agent Resources' : 'Cloud Apps'}</div>
                        </div>
                    </div>
                </div>
            `;
                }).join('');
            }
            
            grid.innerHTML = identityTypeFiltersHTML + userCardsHTML;
        }
        
        function renderUserDetails(gaps, userName) {
            const grid = document.getElementById('resultsGrid');
            
            if (gaps.length === 0) {
                grid.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">📭</div>
                        <div class="empty-state-text">No gaps found</div>
                        <p>Try adjusting the filters above</p>
                    </div>
                `;
                return;
            }
            
            const backButton = `<button class="back-button" onclick="backToAggregated()">← Back to all results</button>`;
            
            // Build filters HTML
            const filtersHTML = buildDynamicFiltersHTML(currentUserGaps);
            
            // Build pagination controls
            const totalPages = Math.ceil(totalGaps / pageSize);
            const paginationHTML = buildPaginationControls(currentPage, totalPages, totalGaps);
            
            // Show filtered count if filters are active
            const filterActive = Object.keys(activeFilters).length > 0;
            const countText = filterActive 
                ? `<strong>${gaps.length}</strong> of <strong>${totalGaps}</strong> gaps (filtered)`
                : `<strong>${totalGaps}</strong> gaps found`;
            
            // Determine user type label and emoji based on scan assignments
            let userTypeLabel = 'Member User';
            let userTypeEmoji = '👤';
            if (currentAnalysisMetadata && currentAnalysisMetadata.assignments) {
                const assignmentType = currentAnalysisMetadata.assignments;
                if (assignmentType === 'users') {
                    userTypeLabel = 'member user';
                    userTypeEmoji = '👤';
                } else if (assignmentType === 'guests') {
                    userTypeLabel = 'guest user';
                    userTypeEmoji = '💼';
                } else if (assignmentType === 'agent-identities') {
                    userTypeLabel = 'agent identity';
                    userTypeEmoji = '🤖';
                } else if (assignmentType === 'workload-identities') {
                    userTypeLabel = 'workload identity';
                    userTypeEmoji = '🚀';
                }
            } else if (gaps.length > 0) {
                // Fallback to first gap's type if metadata not available
                const type = gaps[0].user_type;
                if (type === 'group') {
                    userTypeLabel = 'group';
                    userTypeEmoji = '👤';
                } else if (type === 'role') {
                    userTypeLabel = 'Entra Role';
                    userTypeEmoji = '🎭';
                } else if (type === 'agent_identity') {
                    userTypeLabel = 'agent identity';
                    userTypeEmoji = '🤖';
                } else if (type === 'workload_identity') {
                    userTypeLabel = 'workload identity';
                    userTypeEmoji = '🚀';
                } else if (type === 'guest' || type === 'guests') {
                    userTypeLabel = 'guest user';
                    userTypeEmoji = '💼';
                }
            }
            
            const detailHeader = `
                <div class="detail-view-header" style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <div class="detail-view-title">
                            ${userTypeEmoji} ${userName}
                            <span class="user-type-badge">${userTypeLabel}</span>
                        </div>
                        <div class="detail-view-stats">
                            <span>${countText}</span>
                        </div>
                    </div>
                    <a href="https://portal.azure.com/#view/Microsoft_AAD_ConditionalAccess/WhatIf.ReactView" 
                       target="_blank" 
                       class="btn" 
                       style="text-decoration: none; white-space: nowrap; margin-left: 20px;"
                       title="Test with the official Conditional Access What If tool in the Azure Portal (redirect)"
                       oncontextmenu="return true;">
                        🚀 Test with What If
                    </a>
                </div>
            `;
            
            const gapCards = gaps.map((gap, index) => {
                // Detect if this is a universal gap (handles both boolean true and integer 1)
                const isUniversalGap = !!gap.is_universal_gap;
                
                // Parse lineage into access path steps
                const steps = [];
                const summaryItems = [];
                
                // User is included in expanded view (steps) but not in collapsed view (summaryItems)
                if (gap.user_display_name) {
                    // Determine identity type based on scan assignments metadata
                    let userTypeLabel = 'Member User';
                    let userTypeIcon = '👤';
                    let userDisplayValue = gap.user_display_name;
                    
                    // Check if this affects all identities (display name is 'all')
                    const isAllIdentities = (gap.user_display_name && gap.user_display_name.toLowerCase() === 'all');
                    
                    if (currentAnalysisMetadata && currentAnalysisMetadata.assignments) {
                        const assignmentType = currentAnalysisMetadata.assignments;
                        if (assignmentType === 'users') {
                            userTypeLabel = 'Member User';
                            userTypeIcon = '👤';
                            if (isAllIdentities) userDisplayValue = 'Any';
                        } else if (assignmentType === 'guests') {
                            userTypeLabel = 'Guest User';
                            userTypeIcon = '💼';
                            if (isAllIdentities) userDisplayValue = 'Any';
                        } else if (assignmentType === 'agent-identities') {
                            userTypeLabel = 'Agent Identity';
                            userTypeIcon = '🤖';
                            if (isAllIdentities) userDisplayValue = 'Any';
                        } else if (assignmentType === 'workload-identities') {
                            userTypeLabel = 'Workload Identity';
                            userTypeIcon = '🚀';
                            if (isAllIdentities) userDisplayValue = 'Any';
                        }
                    } else {
                        // Fallback to user_type field if metadata not available
                        if (gap.user_type === 'group') {
                            userTypeLabel = 'Group';
                            userTypeIcon = '👤';
                        } else if (gap.user_type === 'role') {
                            userTypeLabel = 'Entra Role';
                            userTypeIcon = '🎭';
                        } else if (gap.user_type === 'agent_identity') {
                            userTypeLabel = 'Agent Identity';
                            userTypeIcon = '🤖';
                        } else if (gap.user_type === 'workload_identity') {
                            userTypeLabel = 'Workload Identity';
                            userTypeIcon = '🚀';
                        } else if (gap.user_type === 'guest' || gap.user_type === 'guests') {
                            userTypeLabel = 'Guest User';
                            userTypeIcon = '💼';
                        }
                        // For critical gaps affecting all identities without metadata, show generic "Any"
                        if (isAllIdentities) userDisplayValue = 'Any';
                    }
                    
                    steps.push({ icon: userTypeIcon, label: userTypeLabel, value: userDisplayValue });
                }
                if (gap.client_app_type) {
                    const clientAppDisplay = getFormattedClientAppType(gap.client_app_type);
                    const clientAppSummaryLabel = clientAppDisplay === 'Any' ? 'Any Client App Type' : clientAppDisplay;
                    steps.push({ icon: '💻', label: 'Client App Type', value: clientAppDisplay });
                    summaryItems.push(`<span class="icon">💻</span><span class="label">${clientAppSummaryLabel}</span>`);
                }
                if (gap.location_name) {
                    // For universal gaps or 'all', always show "Any" in access path, but full label in summary
                    const locationDisplay = (isUniversalGap || gap.location_name.toLowerCase() === 'all') ? 'Any' : capitalizeValue(gap.location_name);
                    const locationSummaryLabel = locationDisplay === 'Any' ? 'Any Location' : locationDisplay;
                    steps.push({ icon: '📍', label: 'Location', value: locationDisplay });
                    summaryItems.push(`<span class="icon">📍</span><span class="label">${locationSummaryLabel}</span>`);
                }
                if (gap.platform) {
                    const platformDisplay = getFormattedDisplayValue(gap.platform, true);
                    const platformSummaryLabel = platformDisplay === 'Any' ? 'Any Platform' : platformDisplay;
                    steps.push({ icon: '🖥️', label: 'Platform', value: platformDisplay });
                    summaryItems.push(`<span class="icon">🖥️</span><span class="label">${platformSummaryLabel}</span>`);
                }
                if (gap.resource_app_name) {
                    let resourceDisplay;
                    if (isUniversalGap || gap.resource_app_name.toLowerCase() === 'all') {
                        // For universal gaps, show "Any" in access path
                        resourceDisplay = 'Any';
                    } else {
                        resourceDisplay = capitalizeValue(gap.resource_app_name);
                    }
                    
                    // Determine icon and label based on target resource type
                    let targetIcon = '📱';
                    let targetLabel = 'Target App';
                    let resourceSummaryLabel = resourceDisplay;
                    if (currentAnalysisMetadata && currentAnalysisMetadata.target_resources) {
                        const targetType = currentAnalysisMetadata.target_resources;
                        if (targetType === 'cloud-apps') {
                            targetIcon = '📱';
                            targetLabel = 'Target Cloud App';
                            if (resourceDisplay === 'Any') resourceSummaryLabel = 'Any Cloud App';
                        } else if (targetType === 'user-actions') {
                            targetIcon = '👆';
                            targetLabel = 'Target User Action';
                            if (resourceDisplay === 'Any') resourceSummaryLabel = 'Any User Action';
                        } else if (targetType === 'agent-resources') {
                            targetIcon = '🤖';
                            targetLabel = 'Target Agent Resource';
                            if (resourceDisplay === 'Any') resourceSummaryLabel = 'Any Agent Resource';
                        }
                    }
                    
                    steps.push({ icon: targetIcon, label: targetLabel, value: resourceDisplay });
                    summaryItems.push(`<span class="icon">${targetIcon}</span><span class="label">${resourceSummaryLabel}</span>`);
                }
                
                // Determine gap message based on assignment type
                let gapMessage = '❌ Gap: No Block/MFA/Auth Strength Policy';
                if (currentAnalysisMetadata && currentAnalysisMetadata.assignments) {
                    const assignmentType = currentAnalysisMetadata.assignments;
                    if (assignmentType === 'agent-identities' || assignmentType === 'workload-identities') {
                        gapMessage = '❌ Gap: No Block Policy';
                    }
                }
                
                const accessPathHtml = `
                    <div class="access-path">
                        <div class="access-path-title">
                            ⚠️ Access Path #${index + 1}
                        </div>
                        <div class="access-path-steps">
                            ${steps.map((step, i) => `
                                <div class="access-step">
                                    <div class="access-step-icon">${step.icon}</div>
                                    <div class="access-step-content">
                                        <div class="access-step-label">${step.label}</div>
                                        <div class="access-step-value">${step.value}</div>
                                    </div>
                                </div>
                                ${i < steps.length - 1 ? '<div class="access-arrow">⬇️</div>' : ''}
                            `).join('')}
                            <div class="access-arrow" style="color: #f44336;">${gapMessage}</div>
                        </div>
                        ${gap.gap_source ? `
                            <div class="gap-source-info" style="margin-top: 20px; padding: 15px; background: #fff3cd; border-radius: 8px; border-left: 4px solid #ffc107;">
                                <div style="font-weight: 600; color: #856404; margin-bottom: 8px;">
                                    📋 Gap Source: ${gap.gap_source.displayName || gap.gap_source.id}
                                    <span style="background: #856404; color: white; padding: 2px 8px; border-radius: 12px; font-size: 11px; margin-left: 8px;">${gap.gap_source.type}</span>
                                </div>
                                ${gap.exposed_identities && gap.exposed_identities.length > 0 ? `
                                    <div style="margin-top: 10px;">
                                        <div style="font-weight: 600; color: #721c24; margin-bottom: 8px;">
                                            ⚠️ ${gap.exposed_identities.length} ${gap.exposed_identities.length !== 1 ? 'Identities' : 'Identity'} Actually Exposed:
                                        </div>
                                        <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                                            ${gap.exposed_identities.slice(0, 10).map(identity => `
                                                <div style="background: white; padding: 6px 12px; border-radius: 6px; font-size: 13px; border: 1px solid #dee2e6;">
                                                    👤 ${identity.displayName || identity.id}
                                                </div>
                                            `).join('')}
                                            ${gap.exposed_identities.length > 10 ? `
                                                <div style="background: #f8f9fa; padding: 6px 12px; border-radius: 6px; font-size: 13px; color: #6c757d; border: 1px solid #dee2e6;">
                                                    +${gap.exposed_identities.length - 10} more...
                                                </div>
                                            ` : ''}
                                        </div>
                                        <div style="margin-top: 8px; font-size: 12px; color: #6c757d; font-style: italic;">
                                            Note: Other members of this ${gap.gap_source.type} are covered by other policies
                                        </div>
                                    </div>
                                ` : gap.gap_source.type === 'universal' ? `
                                    <div style="margin-top: 10px; color: #721c24; font-weight: 600;">
                                        ⚠️ CRITICAL: Universal gap affects ALL identities in the tenant
                                    </div>
                                ` : ''}
                            </div>
                        ` : ''}
                    </div>
                `;
                
                return `
                    <div class="gap-card${isUniversalGap ? ' critical' : ''}">
                        ${isUniversalGap ? `
                            <div style="background: #fef3cd; border-left: 4px solid #ff6b35; padding: 12px; margin-bottom: 12px; border-radius: 4px; display: flex; align-items: center; gap: 10px;">
                                <span style="font-size: 20px;">⚠️</span>
                                <div>
                                    <span class="user-type-badge" style="background: #ff6b35; color: white; font-weight: 700; border: 1px solid rgba(255,107,53,0.3); box-shadow: 0 2px 8px rgba(255,107,53,0.3); display: inline-block; margin-bottom: 4px;">⚠️ CRITICAL - Universal Gap</span>
                                    <span style="color: #856404; font-size: 13px; display: block;">This gap represents complete lack of protection across ALL possible access paths for this identity</span>
                                </div>
                            </div>
                        ` : ''}
                        <div class="gap-card-header" onclick="toggleGapCard(${index})">
                            <div class="gap-card-title">
                                <span>⚠️</span>
                                <span>Gap #${index + 1}</span>
                            </div>
                            <div class="gap-summary">
                                ${summaryItems.map((item, i) => 
                                    `<div class="gap-summary-item">${item}</div>${i < summaryItems.length - 1 ? '<div class="gap-summary-plus">+</div>' : ''}`
                                ).join('')}
                            </div>
                            <div class="gap-card-expand-icon" id="expand-icon-${index}">▼</div>
                        </div>
                        <div class="gap-card-content" id="gap-content-${index}">
                            ${accessPathHtml}
                        </div>
                    </div>
                `;
            }).join('');
            
            grid.innerHTML = backButton + filtersHTML + paginationHTML + detailHeader + gapCards;
        }
        
        function buildPaginationControls(page, totalPages, totalResults) {
            if (totalPages <= 1) return ''; // No pagination needed
            
            const startResult = (page - 1) * pageSize + 1;
            const endResult = Math.min(page * pageSize, totalResults);
            
            // Build page number buttons (show current, prev 2, next 2)
            let pageButtons = [];
            const minPage = Math.max(1, page - 2);
            const maxPage = Math.min(totalPages, page + 2);
            
            // Add first page if not in range
            if (minPage > 1) {
                pageButtons.push(`<button class="page-btn" onclick="loadUserGapsPage(1)">1</button>`);
                if (minPage > 2) {
                    pageButtons.push(`<span class="page-ellipsis">...</span>`);
                }
            }
            
            // Add page range
            for (let i = minPage; i <= maxPage; i++) {
                const activeClass = i === page ? 'active' : '';
                pageButtons.push(`<button class="page-btn ${activeClass}\" onclick=\"loadUserGapsPage(${i})\">${i}</button>`);
            }
            
            // Add last page if not in range
            if (maxPage < totalPages) {
                if (maxPage < totalPages - 1) {
                    pageButtons.push(`<span class="page-ellipsis">...</span>`);
                }
                pageButtons.push(`<button class="page-btn" onclick="loadUserGapsPage(${totalPages})\">${totalPages}</button>`);
            }
            
            return `
                <div class="pagination-controls">
                    <button class="pagination-nav" onclick="loadUserGapsPage(${page - 1})\" ${page <= 1 ? 'disabled' : ''}>
                        ← Previous
                    </button>
                    <div class="pagination-info">
                        <span class="result-range">Showing ${startResult}-${endResult} of ${totalResults}</span>
                        <div class="page-numbers">
                            ${pageButtons.join('')}
                        </div>
                    </div>
                    <button class="pagination-nav" onclick="loadUserGapsPage(${page + 1})\" ${page >= totalPages ? 'disabled' : ''}>
                        Next →
                    </button>
                </div>
            `;
        }
        
        function toggleGapCard(index) {
            const content = document.getElementById(`gap-content-${index}`);
            const icon = document.getElementById(`expand-icon-${index}`);
            const header = content.previousElementSibling;
            
            content.classList.toggle('expanded');
            icon.classList.toggle('expanded');
            header.classList.toggle('expanded');
        }
        
        function renderResults(results) {
            const grid = document.getElementById('resultsGrid');
            
            if (results.length === 0) {
                grid.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">📭</div>
                        <div class="empty-state-text">No results found</div>
                        <p>Try adjusting your filters</p>
                    </div>
                `;
                return;
            }
            
            grid.innerHTML = results.map((result, index) => {
                // Check if this is a universal gap (handles both boolean true and integer 1)
                const isUniversalGap = !!result.is_universal_gap;
                
                // Check if this is a group and has user count
                let userCountBadge = '';
                if (result.user_type === 'group' && result.user_count) {
                    userCountBadge = ` <span style="background: #0078d4; color: white; padding: 2px 8px; border-radius: 12px; font-size: 11px; font-weight: 600; margin-left: 8px;">${result.user_count} users</span>`;
                }
                
                // Add critical warning for universal gaps
                const universalGapWarning = isUniversalGap ? `
                    <div style="background: #fef3cd; border-left: 4px solid #ff6b35; padding: 12px; margin-bottom: 12px; border-radius: 4px; display: flex; align-items: center; gap: 10px;">
                        <span style="font-size: 20px;">⚠️</span>
                        <div>
                            <span class="user-type-badge" style="background: #ff6b35; color: white; font-weight: 700; border: 1px solid rgba(255,107,53,0.3); box-shadow: 0 2px 8px rgba(255,107,53,0.3); display: inline-block; margin-bottom: 4px;">⚠️ CRITICAL - Universal Gap</span>
                            <span style="color: #856404; font-size: 13px; display: block;">This gap represents complete lack of protection across ALL possible access paths</span>
                        </div>
                    </div>
                ` : '';
                
                return `
                <div class="result-card${isUniversalGap ? ' critical' : ''}">
                    ${universalGapWarning}
                    <div class="result-header">
                        <div class="result-info">
                            <div class="result-user">${result.user_display_name || 'Unknown User'}${userCountBadge}</div>
                            <div class="result-app">📱 ${result.resource_app_name || 'Any'} | 💻 ${result.client_app_type || 'Any'} | � ${result.location_name || 'Any'}</div>
                        </div>
                    </div>
                    
                    ${result.lineage_display ? `
                        <div class="result-lineage"><strong>Unterminated Path:</strong><br>${result.lineage_display}</div>
                    ` : ''}
                </div>
                `;
            }).join('');
        }
        
        function togglePolicies(index) {
            const list = document.getElementById(`policies-${index}`);
            const toggle = document.getElementById(`toggle-${index}`);
            
            list.classList.toggle('expanded');
            toggle.textContent = list.classList.contains('expanded') ? '▲' : '▼';
        }
        
        function applyFilters() {
            currentPage = 0;
            loadResults();
        }
        
        function updatePagination() {
            const totalPages = Math.ceil(totalResults / pageSize);
            const pageInfo = document.getElementById('pageInfo');
            pageInfo.textContent = `Page ${currentPage + 1} of ${totalPages}`;
        }
        
        function nextPage() {
            const totalPages = Math.ceil(totalResults / pageSize);
            if (currentPage < totalPages - 1) {
                currentPage++;
                loadResults();
            }
        }
        
        function prevPage() {
            if (currentPage > 0) {
                currentPage--;
                loadResults();
            }
        }
        
        function showMessage(type, message) {
            const messageArea = document.getElementById('messageArea');
            messageArea.innerHTML = `<div class="${type}">${message}</div>`;
            
            if (type === 'success' || type === 'info') {
                setTimeout(() => {
                    messageArea.innerHTML = '';
                }, 5000);
            }
        }
        
        // Note: results are only shown when the user explicitly clicks "View Results" or uploads a file.
        
        // Tab switching
        function switchTab(tabName, clickedButton, keepTenantSelection = false) {
            // Hide all tab content
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });

            // Remove active class from all top tabs, sidebar nav items, and tenant submenus
            document.querySelectorAll('.tab, .sidebar-nav-item').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.sidebar-nav-subitem').forEach(b => b.classList.remove('active'));

            // Clear tenant selection unless navigating via a tenant submenu click
            if (!keepTenantSelection) {
                window.activeTenantId = null;
            }
            
            // Show selected tab content
            document.getElementById(tabName).classList.add('active');
            
            // Activate the clicked button
            clickedButton.classList.add('active');

            // Sync the other nav set so both always reflect the active tab
            const topTab = document.querySelector(`.tab[onclick*="'${tabName}'"]`);
            if (topTab && topTab !== clickedButton) topTab.classList.add('active');

            const sidebarItem = document.querySelector(`.sidebar-nav-item[data-tab="${tabName}"]`);
            if (sidebarItem && sidebarItem !== clickedButton) sidebarItem.classList.add('active');

            // Expand sidebar and show filters panel when Policy Browser is active
            if (tabName === 'policyBrowser') {
                document.body.classList.add('policy-browser-active');
            } else {
                document.body.classList.remove('policy-browser-active');
            }
        }
        
        // Opens Gap Analysis tab directly (main sidebar button) — upload-only view
        function openGapAnalysis(btn) {
            switchTab('gapAnalysis', btn);
            // Clear any active tenant submenu and stored state
            document.querySelectorAll('.sidebar-nav-subitem').forEach(b => b.classList.remove('active'));
            window.activeTenantId = null;
            currentRunId = null;
            // Show only the upload area
            document.getElementById('gapAnalysisScanHistory').style.display = 'none';
            document.getElementById('uploadSectionLarge').classList.remove('hidden');
            document.getElementById('uploadSectionCompact').classList.add('hidden');
            document.getElementById('statsSection').classList.add('hidden');
            document.getElementById('resultsSection').classList.add('hidden');
            document.getElementById('filtersSection').classList.add('hidden');
            document.getElementById('messageArea').innerHTML = '';
        }

        // Excluded Policies Modal Functions
        async function showExcludedPolicies() {
            if (!currentRunId) {
                showMessage('error', 'No analysis loaded');
                return;
            }
            
            try {
                const response = await fetch(`${API_BASE}/api/runs/${currentRunId}/excluded-policies`);
                const data = await response.json();
                
                const modal = document.getElementById('excludedPoliciesModal');
                const listContainer = document.getElementById('excludedPoliciesList');
                
                // Store policies globally for search filtering
                window.currentExcludedPolicies = data.excludedPolicies || [];
                
                if (!data.excludedPolicies || data.excludedPolicies.length === 0) {
                    listContainer.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-state-icon">✅</div>
                            <div class="empty-state-text">No Policies Excluded</div>
                            <p>All policies passed the evaluation criteria for gap analysis.</p>
                        </div>
                    `;
                    document.getElementById('excludedPoliciesSearch').style.display = 'none';
                } else {
                    document.getElementById('excludedPoliciesSearch').style.display = 'block';
                    document.getElementById('excludedPoliciesSearch').value = '';
                    renderExcludedPoliciesList(data.excludedPolicies);
                }
                
                modal.classList.add('active');
            } catch (error) {
                showMessage('error', `Failed to load excluded policies: ${error.message}`);
            }
        }
        
        function renderExcludedPoliciesList(policies) {
            const listContainer = document.getElementById('excludedPoliciesList');
            
            if (policies.length === 0) {
                listContainer.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">🔍</div>
                        <div class="empty-state-text">No policies found</div>
                        <p>Try a different search term</p>
                    </div>
                `;
                return;
            }
            
            // Group policies by exclusion reason
            const grouped = {};
            policies.forEach(policy => {
                const reason = policy.reason || 'Unknown reason';
                if (!grouped[reason]) {
                    grouped[reason] = [];
                }
                grouped[reason].push(policy);
            });
                    
            // Sort policies alphabetically within each group
            Object.keys(grouped).forEach(reason => {
                grouped[reason].sort((a, b) => a.displayName.localeCompare(b.displayName));
            });
            
            // Sort groups by reason alphabetically
            const sortedReasons = Object.keys(grouped).sort();
            
            // Build HTML with groups
            listContainer.innerHTML = sortedReasons.map(reason => `
                <div style="margin-bottom: 25px;">
                    <div style="font-weight: 600; color: #667eea; margin-bottom: 10px; padding: 8px; background: #f5f7ff; border-radius: 6px;">
                        ${reason}
                    </div>
                    ${grouped[reason].map(policy => `
                        <div class="excluded-policy-item">
                            <div class="excluded-policy-name">${policy.displayName}</div>
                        </div>
                    `).join('')}
                </div>
            `).join('');
        }
        
        function filterExcludedPolicies() {
            const searchTerm = document.getElementById('excludedPoliciesSearch').value.toLowerCase();
            
            if (!window.currentExcludedPolicies) return;
            
            const filteredPolicies = window.currentExcludedPolicies.filter(policy => 
                policy.displayName.toLowerCase().includes(searchTerm)
            );
            
            renderExcludedPoliciesList(filteredPolicies);
        }
        
        function closeExcludedPoliciesModal(event) {
            const modal = document.getElementById('excludedPoliciesModal');
            // Close if clicking backdrop or close button
            if (!event || event.target === modal || event.target.classList.contains('modal-close')) {
                modal.classList.remove('active');
            }
        }
        
        // Close modal on Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeExcludedPoliciesModal();
            }
        });
        
        // ====================================================================
        // IDENTITY FILTER MANAGEMENT FUNCTIONS
        // ====================================================================
        
        // Store IDs with their types: Map<id, type> where type is 'users'|'groups'|'roles'
        let includeIds = new Map();
        let excludeIds = new Map();
        
        function updateFilterMode() {
            const mode = document.getElementById('filterMode').value;
            const includeSection = document.getElementById('includeFilterSection');
            const excludeSection = document.getElementById('excludeFilterSection');
            
            // Show/hide sections based on mode
            includeSection.style.display = (mode === 'include') ? 'block' : 'none';
            excludeSection.style.display = (mode === 'exclude') ? 'block' : 'none';
            
            updateFilterSummary();
        }
        
        function addIncludeId() {
            const input = document.getElementById('includeIdInput');
            const typeSelect = document.getElementById('includeIdType');
            const id = input.value.trim();
            const type =typeSelect.value;
            
            if (!id) return;
            
            // Validate GUID format
            const guidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
            if (!guidRegex.test(id)) {
                showMessage('error', 'Invalid GUID format. Please use format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx');
                return;
            }
            
            if (includeIds.has(id)) {
                showMessage('warning', 'ID already in include list');
                return;
            }
            
            includeIds.set(id, type);
            input.value = '';
            renderIncludeIds();
            checkForConflicts();
            updateFilterSummary();
        }
        
        function removeIncludeId(id) {
            includeIds.delete(id);
            renderIncludeIds();
            checkForConflicts();
            updateFilterSummary();
        }
        
        function getTypeBadge(type) {
            const badges = {
                'users': '<span style="background: #3b82f6; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px; font-weight: 600; margin-right: 5px;">👤 USER</span>',
                'groups': '<span style="background: #8b5cf6; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px; font-weight: 600; margin-right: 5px;">👥 GROUP</span>',
                'roles': '<span style="background: #ec4899; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px; font-weight: 600; margin-right: 5px;">🎭 ROLE</span>'
            };
            return badges[type] || '';
        }
        
        function renderIncludeIds() {
            const container = document.getElementById('includeIdsList');
            if (includeIds.size === 0) {
                container.innerHTML = '<div style="text-align: center; color: #999; padding: 10px; font-size: 12px;">No IDs added yet</div>';
                return;
            }
            
            container.innerHTML = Array.from(includeIds.entries()).map(([id, type]) => `
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px; background: #f0fdf4; border: 1px solid #bbf7d0; border-radius: 4px; margin-bottom: 5px; font-size: 11px;">
                    <div style="display: flex; align-items: center; flex: 1; min-width: 0;">
                        ${getTypeBadge(type)}
                        <span style="color: #166534; font-family: monospace; overflow: hidden; text-overflow: ellipsis;">${id}</span>
                    </div>
                    <button type="button" onclick="removeIncludeId('${id}')" style="background: #ef4444; color: white; border: none; padding: 3px 8px; border-radius: 3px; cursor: pointer; font-size: 11px; margin-left: 8px; flex-shrink: 0;">✕</button>
                </div>
            `).join('');
        }
        
        function addExcludeId() {
            const input = document.getElementById('excludeIdInput');
            const typeSelect = document.getElementById('excludeIdType');
            const id = input.value.trim();
            const type = typeSelect.value;
            
            if (!id) return;
            
            // Validate GUID format
            const guidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
            if (!guidRegex.test(id)) {
                showMessage('error', 'Invalid GUID format. Please use format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx');
                return;
            }
            
            if (excludeIds.has(id)) {
                showMessage('warning', 'ID already in exclude list');
                return;
            }
            
            excludeIds.set(id, type);
            input.value = '';
            renderExcludeIds();
            checkForConflicts();
            updateFilterSummary();
        }
        
        function removeExcludeId(id) {
            excludeIds.delete(id);
            renderExcludeIds();
            checkForConflicts();
            updateFilterSummary();
        }
        
        function renderExcludeIds() {
            const container = document.getElementById('excludeIdsList');
            if (excludeIds.size === 0) {
                container.innerHTML = '<div style="text-align: center; color: #999; padding: 10px; font-size: 12px;">No IDs added yet</div>';
                return;
            }
            
            container.innerHTML = Array.from(excludeIds.entries()).map(([id, type]) => `
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px; background: #fef2f2; border: 1px solid #fecaca; border-radius: 4px; margin-bottom: 5px; font-size: 11px;">
                    <div style="display: flex; align-items: center; flex: 1; min-width: 0;">
                        ${getTypeBadge(type)}
                        <span style="color: #991b1b; font-family: monospace; overflow: hidden; text-overflow: ellipsis;">${id}</span>
                    </div>
                    <button type="button" onclick="removeExcludeId('${id}')" style="background: #ef4444; color: white; border: none; padding: 3px 8px; border-radius: 3px; cursor: pointer; font-size: 11px; margin-left: 8px; flex-shrink: 0;">✕</button>
                </div>
            `).join('');
        }
        
        function checkForConflicts() {
            const conflicts = [...includeIds].filter(id => excludeIds.has(id));
            const warningDiv = document.getElementById('filterConflictWarning');
            const messageSpan = document.getElementById('conflictMessage');
            
            if (conflicts.length > 0) {
                const conflictList = conflicts.slice(0, 3).join(', ');
                const moreText = conflicts.length > 3 ? ` and ${conflicts.length - 3} more` : '';
                messageSpan.textContent = `${conflicts.length} ID(s) appear in both lists: ${conflictList}${moreText}. Please remove conflicts before starting scan.`;
                warningDiv.style.display = 'block';
            } else {
                warningDiv.style.display = 'none';
            }
        }
        
        function updateFilterSummary() {
            const mode = document.getElementById('filterMode').value;
            const summary = document.getElementById('filterSummary');
            const summaryText = document.getElementById('filterSummaryText');
            
            if (mode === 'none' || (includeIds.size === 0 && excludeIds.size === 0)) {
                summary.style.display = 'none';
                return;
            }
            
            let text = '';
            if (mode === 'include') {
                text = `${includeIds.size} ID(s) in allowlist`;
            } else if (mode === 'exclude') {
                text = `${excludeIds.size} ID(s) in blocklist`;
            }
            
            summaryText.textContent = text;
            summary.style.display = 'block';
        }
        
        // ====================================================================
        // FILTER FILE IMPORT/EXPORT FUNCTIONS
        // ====================================================================
        
        function importFilterFile() {
            // Trigger file input click
            document.getElementById('filterFileInput').click();
        }
        
        function handleFilterFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            // Validate file type
            if (!file.name.endsWith('.json')) {
                showMessage('error', 'Please select a valid JSON file');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const fileContent = e.target.result;
                    const filterData = JSON.parse(fileContent);
                    
                    // Validate structure
                    if (typeof filterData !== 'object' || filterData === null) {
                        throw new Error('Filter file must contain a JSON object');
                    }
                    
                    // Clear existing filters
                    includeIds.clear();
                    excludeIds.clear();
                    
                    // Import IDs
                    let importedInclude = 0;
                    let importedExclude = 0;
                    
                    // Handle new format (separate arrays for users/groups/roles)
                    if (filterData.include && typeof filterData.include === 'object' && !Array.isArray(filterData.include)) {
                        // New format
                        ['users', 'groups', 'roles'].forEach(type => {
                            if (filterData.include[type] && Array.isArray(filterData.include[type])) {
                                filterData.include[type].forEach(id => {
                                    const cleanId = id.trim();
                                    if (cleanId) {
                                        includeIds.set(cleanId, type);
                                        importedInclude++;
                                    }
                                });
                            }
                        });
                    } else if (filterData.include && Array.isArray(filterData.include)) {
                        // Legacy format - assume they're users
                        filterData.include.forEach(id => {
                            const cleanId = id.trim();
                            if (cleanId) {
                                includeIds.set(cleanId, 'users');
                                importedInclude++;
                            }
                        });
                    }
                    
                    // Handle exclude field (same logic)
                    if (filterData.exclude && typeof filterData.exclude === 'object' && !Array.isArray(filterData.exclude)) {
                        // New format
                        ['users', 'groups', 'roles'].forEach(type => {
                            if (filterData.exclude[type] && Array.isArray(filterData.exclude[type])) {
                                filterData.exclude[type].forEach(id => {
                                    const cleanId = id.trim();
                                    if (cleanId) {
                                        excludeIds.set(cleanId, type);
                                        importedExclude++;
                                    }
                                });
                            }
                        });
                    } else if (filterData.exclude && Array.isArray(filterData.exclude)) {
                        // Legacy format - assume they're users
                        filterData.exclude.forEach(id => {
                            const cleanId = id.trim();
                            if (cleanId) {
                                excludeIds.set(cleanId, 'users');
                                importedExclude++;
                            }
                        });
                    }
                    
                    // Update filter mode based on imported data
                    const filterMode = document.getElementById('filterMode');
                    if (importedInclude > 0 && importedExclude === 0) {
                        filterMode.value = 'include';
                    } else if (importedExclude > 0 && importedInclude === 0) {
                        filterMode.value = 'exclude';
                    } else if (importedInclude > 0 || importedExclude > 0) {
                        // Both have values, default to include mode
                        filterMode.value = 'include';
                    }
                    
                    // Update UI
                    updateFilterMode();
                    renderIncludeIds();
                    renderExcludeIds();
                    checkForConflicts();
                    updateFilterSummary();
                    
                    // Show success message
                    const totalImported = importedInclude + importedExclude;
                    let message = `Successfully imported ${totalImported} ID(s)`;
                    if (importedInclude > 0 && importedExclude > 0) {
                        message += ` (${importedInclude} include, ${importedExclude} exclude)`;
                    }
                    showMessage('success', message);
                    
                } catch (error) {
                    showMessage('error', `Failed to import filter file: ${error.message}`);
                    console.error('Filter file import error:', error);
                }
            };
            
            reader.onerror = function() {
                showMessage('error', 'Failed to read filter file');
            };
            
            reader.readAsText(file);
            
            // Reset file input so the same file can be selected again
            event.target.value = '';
        }
        
        function exportFilterConfig() {
            // Determine which IDs to export based on filter mode
            const mode = document.getElementById('filterMode').value;
            
            if (mode === 'none' || (includeIds.size === 0 && excludeIds.size === 0)) {
                showMessage('error', 'No filter configuration to export. Please add some IDs first.');
                return;
            }
            
            // Build filter config object with separate arrays by type
            const filterConfig = {
                include: {
                    users: [],
                    groups: [],
                    roles: []
                },
                exclude: {
                    users: [],
                    groups: [],
                    roles: []
                }
            };
            
            // Organize include IDs by type
            includeIds.forEach((type, id) => {
                if (filterConfig.include[type]) {
                    filterConfig.include[type].push(id);
                }
            });
            
            // Organize exclude IDs by type
            excludeIds.forEach((type, id) => {
                if (filterConfig.exclude[type]) {
                    filterConfig.exclude[type].push(id);
                }
            });
            
            // Create JSON blob
            const jsonString = JSON.stringify(filterConfig, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            
            // Create download link
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            
            // Generate filename with timestamp
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
            link.download = `cainsight-filter-${timestamp}.json`;
            
            // Trigger download
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            // Clean up
            URL.revokeObjectURL(url);
            
            // Show success message
            const totalExported = includeIds.size + excludeIds.size;
            showMessage('success', `Exported filter configuration with ${totalExported} ID(s)`);
        }
        
        // Add Enter key support for adding IDs
        document.addEventListener('DOMContentLoaded', function() {
            const includeInput = document.getElementById('includeIdInput');
            const excludeInput = document.getElementById('excludeIdInput');
            
            if (includeInput) {
                includeInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        addIncludeId();
                    }
                });
            }
            
            if (excludeInput) {
                excludeInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        addExcludeId();
                    }
                });
            }
            
            // Initialize condition checkboxes state based on default selection
            updateConditionCheckboxes();
            
            // Initialize target resources options based on default selection
            updateTargetResourcesOptions();
            
            // Initialize conditions banner
            updateConditionsBanner();
        });
        
        // ====================================================================
        // SCAN MANAGEMENT FUNCTIONS
        // ====================================================================
        
        // Function to update condition checkbox states based on identity type
        // NOTE: This function is now a no-op since conditions are implicitly included
        function updateConditionCheckboxes() {
            // Conditions are now automatically included based on scan type
            // No UI updates needed since condition checkboxes have been removed
        }
        
        // Function to update Target Resources dropdown based on identity type
        function updateTargetResourcesOptions() {
            const assignmentsValue = document.getElementById('assignments').value;
            const targetResourcesSelect = document.getElementById('target_resources');
            const userActionsOption = targetResourcesSelect.querySelector('option[value="user-actions"]');
            
            if (assignmentsValue === 'users' || assignmentsValue === 'guests') {
                // Enable User Actions for member users and guest users
                userActionsOption.disabled = false;
                userActionsOption.style.color = '';
            } else {
                // Disable User Actions for agent and workload identities
                userActionsOption.disabled = true;
                userActionsOption.style.color = '#999';
                
                // If User Actions is currently selected, switch to Cloud Applications
                if (targetResourcesSelect.value === 'user-actions') {
                    targetResourcesSelect.value = 'cloud-apps';
                }
            }
            
            // Update conditions banner
            updateConditionsBanner();
        }
        
        // Function to update the conditions banner based on current selections
        function updateConditionsBanner() {
            const assignments = document.getElementById('assignments').value;
            const targetResources = document.getElementById('target_resources').value;
            const banner = document.getElementById('conditionsBanner');
            const conditionsText = document.getElementById('conditionsText');
            const guestUserActionsBanner = document.getElementById('guestUserActionsBanner');
            
            let conditions = [];
            
            // Show/hide guest user actions info banner
            if (assignments === 'guests' && targetResources === 'user-actions') {
                guestUserActionsBanner.classList.add('visible');
            } else {
                guestUserActionsBanner.classList.remove('visible');
            }
            
            // Determine which conditions are included based on the combination
            if (assignments === 'users' || assignments === 'guests') {
                // Users and Guests support Authentication Flows, Client App Types, and Locations for all target resources
                conditions = ['Authentication Flows', 'Client App Types', 'Locations'];
            } else if (assignments === 'agent-identities') {
                // Agent Identities do not support any conditions
                conditions = ['None (Agent Identities do not support any condition)'];
            } else if (assignments === 'workload-identities') {
                // Workload Identities only support Locations condition
                conditions = ['Locations (Workload Identities support only the Locations condition)'];
            }
            
            // Update banner display
            if (conditions.length > 0) {
                conditionsText.textContent = conditions.join(', ');
                banner.classList.add('visible');
            } else {
                banner.classList.remove('visible');
            }
        }
        
        // Handle identity type selection for condition checkboxes and target resources
        document.getElementById('assignments').addEventListener('change', function() {
            updateConditionCheckboxes();
            updateTargetResourcesOptions();
            updateConditionsBanner();
        });
        
        // Handle target resources selection for conditions banner
        document.getElementById('target_resources').addEventListener('change', function() {
            updateConditionsBanner();
        });
        
        // Handle scan form submission
        document.getElementById('scanForm').addEventListener('submit', async function(e) {
            e.preventDefault();
            
            // Check if we have a valid token
            if (!authToken) {
                showMessage('error', 'Please authenticate first');
                showTokenModal('Please provide a valid access token to start a scan', true);
                return;
            }
            
            // Check for filter conflicts
            const conflicts = [...includeIds].filter(id => excludeIds.has(id));
            if (conflicts.length > 0) {
                showMessage('error', `Cannot start scan: ${conflicts.length} ID(s) appear in both include and exclude lists. Please resolve conflicts first.`);
                return;
            }
            
            const formData = {
                token: authToken, // Use stored token instead of manual input
                assignments: document.getElementById('assignments').value,
                target_resources: document.getElementById('target_resources').value,
                clear_cache: document.querySelector('input[name="clearCache"]:checked').value || null
            };
            
            // Add filter configuration if any filters are set
            const filterMode = document.getElementById('filterMode').value;
            if (filterMode !== 'none' && (includeIds.size > 0 || excludeIds.size > 0)) {
                // Build filter config with separate arrays by type
                formData.filter_config = {
                    include: {
                        users: [],
                        groups: [],
                        roles: []
                    },
                    exclude: {
                        users: [],
                        groups: [],
                        roles: []
                    }
                };
                
                // Organize include IDs by type
                includeIds.forEach((type, id) => {
                    if (formData.filter_config.include[type]) {
                        formData.filter_config.include[type].push(id);
                    }
                });
                
                // Organize exclude IDs by type
                excludeIds.forEach((type, id) => {
                    if (formData.filter_config.exclude[type]) {
                        formData.filter_config.exclude[type].push(id);
                    }
                });
            }
            
            try {
                const response = await fetch(`${API_BASE}/api/scans/start`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(formData)
                });
                
                const result = await response.json();
                
                if (response.status === 401) {
                    // Token expired
                    handleTokenExpiration();
                    return;
                }
                
                if (response.status === 409 && result.scan_already_running) {
                    // Another scan is already running
                    alert('⚠️ Scan Already Running\n\nFor performance reasons, the CAInsight portal can run only one scan at a time. Please wait for the current scan to complete before starting a new one.');
                    showMessage('error', 'Cannot start scan: Another scan is already running');
                    return;
                }
                
                if (response.ok) {
                    const newScanId = result.scan_id;
                    document.getElementById('scanForm').reset();
                    // Load scan history then auto-navigate to the matching tenant submenu
                    await loadScanHistory();
                    let targetTenantId = null;
                    let targetDisplayName = null;
                    for (const [tId, tData] of Object.entries(window.allScansByTenant)) {
                        if (tData.scans.some(s => s.id === newScanId)) {
                            targetTenantId = tId;
                            const fullName = tData.tenantDomain ? tData.tenantDomain.toLowerCase() : tId;
                            targetDisplayName = fullName.length > 50 ? fullName.slice(0, 50) + '\u2026' : fullName;
                            break;
                        }
                    }
                    if (targetTenantId) {
                        // Find the matching sidebar submenu button
                        let matchBtn = null;
                        document.querySelectorAll('.sidebar-nav-subitem').forEach(btn => {
                            const oc = btn.getAttribute('onclick') || '';
                            if (oc.includes(`'${targetTenantId}'`)) matchBtn = btn;
                        });
                        showTenantHistory(targetTenantId, targetDisplayName, matchBtn);
                    } else {
                        showMessage('success', `Scan started! (ID: ${newScanId})`);
                    }
                } else {
                    showMessage('error', result.error || 'Failed to start scan');
                }
            } catch (error) {
                showMessage('error', 'Network error: ' + error.message);
            }
        });
        
        // Auto-refresh interval for running scans
        let scanHistoryRefreshInterval = null;
        
        // Load scan history
        // Stores the last fetched scan list and active tenant selection
        window.allScansByTenant = {};
        window.activeTenantId = null;

        async function loadScanHistory() {
            try {
                const response = await fetch(`${API_BASE}/api/scans`);
                const scans = await response.json();

                // Check if there are any running scans
                const hasRunningScans = scans.some(scan => scan.status === 'running');

                // Start auto-refresh if there are running scans and not already running
                if (hasRunningScans && !scanHistoryRefreshInterval) {
                    scanHistoryRefreshInterval = setInterval(loadScanHistory, 2000);
                } else if (!hasRunningScans && scanHistoryRefreshInterval) {
                    clearInterval(scanHistoryRefreshInterval);
                    scanHistoryRefreshInterval = null;
                }

                // Group scans by tenant_id
                const scansByTenant = {};
                scans.forEach(scan => {
                    const tenantId = scan.tenant_id || 'unknown';
                    if (!scansByTenant[tenantId]) {
                        const tenantDomain = scan.tenant_domain || null;
                        scansByTenant[tenantId] = { tenantDomain, scans: [] };
                    }
                    scansByTenant[tenantId].scans.push(scan);
                });

                // Store globally for use by showTenantHistory
                window.allScansByTenant = scansByTenant;

                // Update sidebar tenant submenus
                updateGapAnalysisSubmenus(scansByTenant);

                // If a tenant is currently displayed, refresh its scan list
                if (window.activeTenantId && scansByTenant[window.activeTenantId]) {
                    const { tenantDomain, scans: tenantScans } = scansByTenant[window.activeTenantId];
                    const displayName = tenantDomain
                        ? tenantDomain.toLowerCase()
                        : window.activeTenantId;
                    document.getElementById('scanHistoryTenantTitle').textContent =
                        `Scan History — ${displayName}`;
                    document.getElementById('scanHistoryContent').innerHTML =
                        renderTenantScansHTML(tenantScans);
                }
            } catch (error) {
                console.error('Error loading scan history:', error);
            }
        }

        function syncSidebarWidth() {
            const subitems = document.querySelectorAll('.sidebar-nav-subitem');
            let maxChars = 0;
            subitems.forEach(btn => {
                const spans = btn.querySelectorAll('span');
                if (spans[1]) maxChars = Math.max(maxChars, spans[1].textContent.length);
            });
            // left-pad 44 + icon 18 + gap 10 + right-pad 20 + badge 34 = 126px overhead
            // ~7.5px per char at 13px sans-serif
            const needed = maxChars > 0 ? Math.ceil(maxChars * 7.5 + 126) : 0;
            const width = Math.min(420, Math.max(240, needed));
            document.documentElement.style.setProperty('--sidebar-width', width + 'px');
        }

        function updateGapAnalysisSubmenus(scansByTenant) {
            const container = document.getElementById('gapAnalysisTenantSubmenus');
            if (!container) return;

            const tenantIds = Object.keys(scansByTenant).sort();

            if (tenantIds.length === 0) {
                container.innerHTML = '';
                syncSidebarWidth();
                return;
            }

            let html = '';
            tenantIds.forEach(tenantId => {
                const { tenantDomain, scans } = scansByTenant[tenantId];
                const fullName = tenantDomain ? tenantDomain.toLowerCase() : tenantId;
                // Truncate at 50 chars to cap sidebar expansion
                const displayName = fullName.length > 50 ? fullName.slice(0, 50) + '\u2026' : fullName;
                const scanCount = scans.length;
                const isActive = tenantId === window.activeTenantId;
                html += `
                    <button class="sidebar-nav-subitem${isActive ? ' active' : ''}"
                            onclick="showTenantHistory('${tenantId}', '${displayName}', this)"
                            title="${fullName} \u2014 ${scanCount} scan${scanCount !== 1 ? 's' : ''}">
                        <span class="sidebar-nav-subitem-icon">☁️</span>
                        <span>${displayName}</span>
                        <span style="margin-left: auto; font-size: 11px; opacity: 0.65; flex-shrink: 0;">${scanCount}</span>
                    </button>`;
            });
            container.innerHTML = html;
            syncSidebarWidth();
        }

        function showTenantHistory(tenantId, displayName, btn) {
            // Switch to Gap Analysis tab — pass keepTenantSelection=true to avoid clearing activeTenantId
            const gapBtn = document.querySelector('.sidebar-nav-item[data-tab="gapAnalysis"]');
            switchTab('gapAnalysis', gapBtn, true);

            // Mark submenu button as active
            document.querySelectorAll('.sidebar-nav-subitem').forEach(b => b.classList.remove('active'));
            if (btn) btn.classList.add('active');

            // Hide upload area — tenant submenu has its own content
            document.getElementById('uploadSectionLarge').classList.add('hidden');
            document.getElementById('uploadSectionCompact').classList.add('hidden');
            document.getElementById('messageArea').innerHTML = '';

            // Store active tenant
            window.activeTenantId = tenantId;

            // Render the tenant's scans
            const tenantData = window.allScansByTenant[tenantId];
            if (!tenantData) return;

            document.getElementById('scanHistoryTenantTitle').textContent =
                `Scan History — ${displayName}`;
            document.getElementById('scanHistoryContent').innerHTML =
                renderTenantScansHTML(tenantData.scans);

            // Show the scan history panel
            document.getElementById('gapAnalysisScanHistory').style.display = 'block';

            // Start auto-refresh if any scans are running
            const hasRunning = tenantData.scans.some(s => s.status === 'running');
            if (hasRunning && !scanHistoryRefreshInterval) {
                scanHistoryRefreshInterval = setInterval(loadScanHistory, 2000);
            }
        }

        function renderTenantScansHTML(tenantScans) {
            if (!tenantScans || tenantScans.length === 0) {
                return '<p style="text-align: center; color: #999; padding: 40px;">No scans found for this tenant.</p>';
            }
            return `
                <table style="width: 100%; border-collapse: collapse;">
                    <thead>
                        <tr style="border-bottom: 2px solid #e0e0e0; background: #f9fafb;">
                            <th style="padding: 12px; text-align: left;">ID</th>
                            <th style="padding: 12px; text-align: left;">Status</th>
                            <th style="padding: 12px; text-align: left;">Configuration</th>
                            <th style="padding: 12px; text-align: left;">Started</th>
                            <th style="padding: 12px; text-align: left;">Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${tenantScans.map(scan => {
                            let statusBadge = '';
                            if (scan.status === 'completed') {
                                statusBadge = '<span style="background: #10b981; color: white; padding: 4px 10px; border-radius: 12px; font-size: 12px;">✓ Completed</span>';
                            } else if (scan.status === 'failed') {
                                statusBadge = '<span style="background: #ef4444; color: white; padding: 4px 10px; border-radius: 12px; font-size: 12px;">✗ Failed</span>';
                            } else {
                                statusBadge = `<span style="background: #f59e0b; color: white; padding: 4px 10px; border-radius: 12px; font-size: 12px;">⏳ Running (${scan.progress_percent}%)</span>`;
                            }

                            const conditions = scan.conditions ? JSON.parse(scan.conditions) : [];
                            const configTags = [
                                formatAssignment(scan.assignments),
                                formatTargetResource(scan.target_resources),
                                ...conditions.map(c => formatCondition(c))
                            ].join('');

                            let filterTags = '';
                            // Check filter config fields (present on all scan states).
                            // Stored as JSON-serialised flat array of GUIDs (get_include_ids / get_exclude_ids).
                            const _parseHasIds = (raw) => {
                                try {
                                    if (!raw) return false;
                                    const v = JSON.parse(raw);
                                    if (Array.isArray(v)) return v.length > 0;
                                    // Fallback: keyed object {users:[...], groups:[...], ...}
                                    return Object.values(v).some(a => Array.isArray(a) && a.length > 0);
                                } catch { return false; }
                            };
                            const _hasInclude = _parseHasIds(scan.include_object_ids);
                            const _hasExclude = _parseHasIds(scan.skip_object_ids);
                            if (_hasInclude) filterTags += `<span style="background: #e5e7eb; color: #374151; padding: 3px 8px; border-radius: 4px; margin-right: 4px; font-size: 12px;">Include Filters</span>`;
                            if (_hasExclude) filterTags += `<span style="background: #e5e7eb; color: #374151; padding: 3px 8px; border-radius: 4px; margin-right: 4px; font-size: 12px;">Exclude Filters</span>`;

                            const started = new Date(scan.started_at).toLocaleString();
                            let actions = '';
                            const outputBtnStyle = scan.status === 'running' ? 'background: #f59e0b;' : 'background: #6b7280;';
                            actions += `<button class="btn-compact" onclick="viewLiveOutput(${scan.id})" style="${outputBtnStyle}">📺 Live Output</button> `;
                            if (scan.status === 'completed' && scan.analysis_run_id) {
                                actions += `<button class="btn-compact" onclick="loadScanResults(${scan.analysis_run_id})">📊 View Results</button> `;
                            }
                            actions += `<button class="btn-compact" onclick="deleteScan(${scan.id})" style="background: #ef4444;">🗑️ Delete</button>`;

                            return `
                                <tr style="border-bottom: 1px solid #f0f0f0;">
                                    <td style="padding: 12px;">${scan.id}</td>
                                    <td style="padding: 12px;">${statusBadge}</td>
                                    <td style="padding: 12px;">${configTags}${filterTags}</td>
                                    <td style="padding: 12px;">${started}</td>
                                    <td style="padding: 12px;">${actions}</td>
                                </tr>`;
                        }).join('')}
                    </tbody>
                </table>`;
        }
        
        function toggleTenantGroup(groupId) {
            const body = document.getElementById(groupId);
            const header = body.previousElementSibling;
            
            body.classList.toggle('collapsed');
            header.classList.toggle('collapsed');
        }
        
        function formatAssignment(value) {
            let label = value;
            if (value === 'users-groups-roles') label = 'Members';
            else if (value === 'users') label = 'Members';
            else if (value === 'agent-identities') label = 'Agent Identities';
            else if (value === 'agents') label = 'Agent Identities';
            else if (value === 'workload-identities') label = 'Workload Identities';
            else if (value === 'guests') label = 'Guests';
            else {
                // Capitalize each word in the fallback case
                label = value.split('-').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
            }
            return `<span style="background: #3b82f6; color: white; padding: 3px 8px; border-radius: 4px; margin-right: 4px; font-size: 12px;">${label}</span>`;
        }
        
        function formatTargetResource(value) {
            let label = value;
            if (value === 'cloud-apps') label = 'Cloud Apps';
            else if (value === 'user-actions') label = 'User Actions';
            else if (value === 'agent-resources') label = 'Agent Resources';
            else {
                // Capitalize each word in the fallback case
                label = value.split('-').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
            }
            return `<span style="background: #ef4444; color: white; padding: 3px 8px; border-radius: 4px; margin-right: 4px; font-size: 12px;">${label}</span>`;
        }
        
        function formatCondition(value) {
            let label = value;
            if (value === 'locations' || value === 'location') label = 'Locations';
            else if (value === 'modern-client-types' || value === 'modern-clients') label = 'Modern Client Types';
            else if (value === 'legacy-client-types' || value === 'legacy-clients') label = 'Legacy Client Types';
            else if (value === 'auth-flows') label = 'Authentication Flows';
            else {
                // Capitalize each word in the fallback case
                label = value.split('-').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
            }
            return `<span style="background: #10b981; color: white; padding: 3px 8px; border-radius: 4px; margin-right: 4px; font-size: 12px;">${label}</span>`;
        }
        
        async function loadScanResults(runId) {
            // Load results inline below the scan history — no tab switch needed
            currentRunId = runId;
            await loadAnalysis();
            showMessage('success', 'Scan results loaded successfully');
            // Scroll smoothly to the results section
            const statsEl = document.getElementById('statsSection');
            if (statsEl) statsEl.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
        
        let liveOutputEventSource = null;
        
        function viewLiveOutput(scanId) {
            // Show modal
            document.getElementById('liveOutputModal').style.display = 'block';
            document.getElementById('modalScanId').textContent = scanId;
            document.getElementById('liveOutputContent').textContent = 'Connecting to live output...\n';
            
            // Close existing connection if any
            if (liveOutputEventSource) {
                liveOutputEventSource.close();
            }
            
            // Connect to SSE endpoint for live logs
            liveOutputEventSource = new EventSource(`${API_BASE}/api/scans/${scanId}/logs`);
            
            liveOutputEventSource.onmessage = function(event) {
                const data = JSON.parse(event.data);
                const content = document.getElementById('liveOutputContent');
                
                if (data.line) {
                    content.textContent += data.line + '\n';
                    // Auto-scroll to bottom
                    content.parentElement.scrollTop = content.parentElement.scrollHeight;
                } else if (data.complete) {
                    content.textContent += '\n=== Scan completed ===\n';
                    liveOutputEventSource.close();
                    liveOutputEventSource = null;
                }
            };
            
            liveOutputEventSource.onerror = function(error) {
                console.error('SSE error:', error);
                document.getElementById('liveOutputContent').textContent += '\n[Connection error or scan completed]\n';
                if (liveOutputEventSource) {
                    liveOutputEventSource.close();
                    liveOutputEventSource = null;
                }
            };
        }
        
        function closeLiveOutput() {
            document.getElementById('liveOutputModal').style.display = 'none';
            if (liveOutputEventSource) {
                liveOutputEventSource.close();
                liveOutputEventSource = null;
            }
        }
        
        async function deleteScan(scanId) {
            if (!confirm('Are you sure you want to delete this scan?')) {
                return;
            }
            
            try {
                const response = await fetch(`${API_BASE}/api/scans/${scanId}/delete`, {
                    method: 'DELETE'
                });
                
                if (response.ok) {
                    showMessage('success', 'Scan deleted successfully');
                    loadScanHistory();
                } else {
                    const result = await response.json();
                    showMessage('error', result.error || 'Failed to delete scan');
                }
            } catch (error) {
                showMessage('error', 'Network error: ' + error.message);
            }
        }
        
        async function clearCacheManual(mode) {
            const cacheTypes = {
                'all': 'all caches',
                'policies': 'policy caches',
                'tenant': 'tenant caches'
            };
            
            const cacheType = cacheTypes[mode] || 'cache';
            
            if (!confirm(`Are you sure you want to clear ${cacheType}?\n\nThis will force the next scan to fetch fresh data from Microsoft Graph API.`)) {
                return;
            }
            
            try {
                const response = await fetch(`${API_BASE}/api/cache/clear`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ mode: mode })
                });
                
                const result = await response.json();
                
                if (response.ok) {
                    showMessage('success', result.message || `Successfully cleared ${cacheType}`);
                } else {
                    showMessage('error', result.error || `Failed to clear ${cacheType}`);
                }
            } catch (error) {
                showMessage('error', 'Network error: ' + error.message);
            }
        }
        
        // Auto-refresh scan history every 5 seconds when scan history is being viewed
        setInterval(() => {
            const gapTab = document.getElementById('gapAnalysis');
            const scanHistoryVisible = document.getElementById('gapAnalysisScanHistory');
            if (gapTab && gapTab.classList.contains('active') &&
                scanHistoryVisible && scanHistoryVisible.style.display !== 'none') {
                loadScanHistory();
            }
        }, 5000);
        
        // Load scan history on page load
        loadScanHistory();
        
        // ====================================================================
        // END SCAN MANAGEMENT FUNCTIONS
        // ====================================================================
    </script>
</body>
</html>
